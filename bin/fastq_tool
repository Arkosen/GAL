#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Statistics::Descriptive;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

fastq_tool -read_count sequence1.fastq [sequence2.fastq ...]

Description:

This script does various conversions and analyses on fastq files.


Options:

  --count	  Return the count of reads in the file
  --lengths	  Print a summary of the read lengths
  --quals	  Print a summary of quality values
  --total	  Print the total length of all reads
  --ill2sanger	  Convert Illumina 1.3+ base quality scores to standard Sanger scores
  --sol2sanger	  Convert Illumina 1.0 base quality scores to standard Sanger scores
  --trim_qual	  Remove reads that don't pass quality filter
  --guess_format  Guess which format (Sanger Solexa/Illumina 1.0 or
		  Illumina 1.3) the file is.

";


my ($help, $count, $lengths, $quals, $total, $ill2sanger, $sol2sanger,
    $trim_qual, $guess_format);
my $opt_success = GetOptions('help'         => \$help,
			     'count'	    => \$count,
			     'lengths'	    => \$lengths,
			     'quals'	    => \$quals,
			     'total'	    => \$total,
			     'ill2sanger'      => \$ill2sanger,
			     'sol2sanger'      => \$sol2sanger,
			     'trim_qual'    => \$trim_qual,
			     'guess_format' => \$guess_format,
			      );

die $usage if $help || ! $opt_success;

my $file = shift;

if ($count) {
    read_count($file);
}
elsif ($lengths) {
    length_summary($file);
}
elsif ($quals) {
    quality_summary($file)
}
elsif ($total) {
    total_read_length($file)
}
elsif ($ill2sanger) {
    ill2sanger($file);
}
elsif ($sol2sanger) {
    sol2sanger($file);
}
elsif ($trim_qual) {
    trim_qualities($file);
}
elsif ($guess_format) {
    guess_format($file);
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub read_count {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub length_summary {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub quality_summary {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub total_read_length {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub ill2sanger {
    my $file = shift;

    my $iterator = make_read_iterator($file);

    my $stat = Statistics::Descriptive::Sparse->new();
    
    my $count;
    my $min;
    while (my $read = &$iterator) {
	chomp @{$read};
	my @quals = split '', $read->[3];
	map {$_ = ord} @quals;
	$stat->add_data(@quals);
	if (++$count == 10000) {
	    $min = $stat->min;
	    last;
	}
    }
    
    my $adjust = $min - 33;
    $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
	chomp @{$read};
	my @quals = split '', $read->[3];
	map {$_ = chr(ord($_) - $adjust)} @quals;
	$read->[3] = join '', @quals;
	print join "\n", @{$read};
	print "\n";
    }
}

#-----------------------------------------------------------------------------

sub sol2sanger {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub trim_qualities {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub guess_format {
    my $file = shift;
    
    my $iterator = make_read_iterator($file);
    
    my $stat = Statistics::Descriptive::Sparse->new();
    
    while (my $read = &$iterator) {
	chomp @{$read};
	my @quals = split '', $read->[3];
	map {$_ = ord} @quals;
	$stat->add_data(@quals);
	unless (++$count % 1000) {
	    my $min = $stat->min;
	    my $max = $stat->max;
	    if ($min < 59) {
		print "Sanger Format\n";
	    }
	    elsif ($min < 64) {
		print "Solexa/Illumina 1.0 Format\n";
	    } 
	    elsif ($min < 66) {
		print "Solexa 1.3 Format\n";
	    } 
	    else {
		print "Solexa 1.5+ Format\n";
	    } 
	}
    }
}
#-----------------------------------------------------------------------------

sub make_read_iterator {

    my $file = shift;

    my $IN;
    if (! -t STDIN) {
	open ($IN, "<&=STDIN") or die "Can't open STDIN\n";
    }
    else {
	open ($IN, '<', $file) or die "Can't open $file for reading:\n$!\n";
    }

    return sub {
	my @data = (<$IN>, <$IN>, <$IN>, <$IN>);
	while ($data[0] !~ /^@/ && $data[2] !~ /^\+/) {
	    shift @data;
	    push @data, <$IN>;
	}
	#die "FATAL : invalid_format : ID line = $id\n" unless $id =~ /^@/;
	#die "FATAL : invalid_format : ID2 line = $id2\n" unless $id2 =~ /^\+/;
	return @fields ? \@fields : undef;
    };
}
