#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Statistics::Descriptive;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

fastq_tool -read_count sequence1.fastq [sequence2.fastq ...]

Description:

This script does various conversions and analyses on fastq files.


Options:

  --count	  Return the count of reads in the file
  --lengths	  Print a summary of the read lengths
  --quals	  Print a summary of quality values
  --total	  Print the total length of all reads
  --ill2sanger	  Convert Illumina 1.3+ base quality scores to standard Sanger scores
  --sol2sanger	  Convert Illumina 1.0 base quality scores to standard Sanger scores
  --trim_qual	  Remove reads that don't pass quality filter
  --guess_format  Guess which format (Sanger Solexa/Illumina 1.0 or
		  Illumina 1.3) the file is.
  --verbose       Talk to me baby!

";


my ($help, $count, $lengths, $quals, $total, $ill2sanger, $sol2sanger,
    $trim_qual, $guess_format, $verbose);
my $opt_success = GetOptions('help'         => \$help,
			     'count'	    => \$count,
			     'lengths'	    => \$lengths,
			     'quals'	    => \$quals,
			     'total'	    => \$total,
			     'ill2sanger'      => \$ill2sanger,
			     'sol2sanger'      => \$sol2sanger,
			     'trim_qual'    => \$trim_qual,
			     'guess_format' => \$guess_format,
			     'verbose'      => \$verbose,
			      );

die $usage if $help || ! $opt_success;

my $file = shift;

die $usage unless -r $file;

if ($count) {
    read_count($file);
}
elsif ($lengths) {
    length_summary($file);
}
elsif ($quals) {
    quality_summary($file)
}
elsif ($total) {
    total_read_length($file)
}
elsif ($ill2sanger) {
    ill2sanger($file);
}
elsif ($sol2sanger) {
    sol2sanger($file);
}
elsif ($trim_qual) {
    trim_qualities($file);
}
elsif ($guess_format) {
    guess_format($file);
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub read_count {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub length_summary {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub quality_summary {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub total_read_length {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub ill2sanger {
    my $file = shift;

    my $iterator = make_read_iterator($file);

    my $stat = Statistics::Descriptive::Sparse->new();
    
    my $count;
    my $min;
    while (my $read = &$iterator) {
	chomp @{$read};
	my @quals = split '', $read->[3];
	map {$_ = ord} @quals;
	$stat->add_data(@quals);
	if (++$count == 10000) {
	    $min = $stat->min;
	    last;
	}
    }
    
    my $adjust = $min - 33;
    $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
	chomp @{$read};
	my @quals = split '', $read->[3];
	map {$_ = chr(ord($_) - $adjust)} @quals;
	$read->[3] = join '', @quals;
	print join "\n", @{$read};
	print "\n";
    }
}

#-----------------------------------------------------------------------------

sub sol2sanger {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub trim_qualities {
    my $file = shift;

    die "Method not yet implimented\n";

    my $iterator = make_read_iterator($file);

    while (my $read = &$iterator) {
    }
}

#-----------------------------------------------------------------------------

sub guess_format {
    my $file = shift;
    
    my $iterator = make_read_iterator($file);
    
    my $stat = Statistics::Descriptive::Sparse->new();
    
    while (my $read = &$iterator) {
	chomp @{$read};
	my @quals = split '', $read->[3];
	map {$_ = ord} @quals;
	$stat->add_data(@quals);
	unless (++$count % 1000) {
	    my $min = $stat->min;
	    my $max = $stat->max;
	    if ($min < 59) {
		print "Sanger Format\n";
	    }
	    elsif ($min < 64) {
		print "Solexa/Illumina 1.0 Format\n";
	    } 
	    elsif ($min < 66) {
		print "Solexa 1.3 Format\n";
	    } 
	    else {
		print "Solexa 1.5+ Format\n";
	    } 
	}
    }
}
#-----------------------------------------------------------------------------

sub make_read_iterator {

    my $file = shift;

    my $IN;
    my $line_count = 1;
    my $read_count = 1;
#    if (! -t STDIN) {
#	open ($IN, "<&=STDIN") or die "Can't open STDIN\n";
#    }
#    else {
    open ($IN, '<', $file) or die "Can't open $file for reading:\n$!\n";
#    }

    return sub {
        my @data;
	for (0 .. 3) {
	    my $line = <$IN>;
	    return undef unless defined $line;
	    push @data, $line;
	}
	chomp @data;
	my $failed;
        while ($data[0] !~ /^@/ && $data[2] !~ /^\+/) {
	    warn "WARN : skipping_bad_lines : " . join("\t", @data) . "\n";
            shift @data;
	    my $line = <$IN>;
	    return undef unless defined $line;
            push @data, $line;
	    $line_count++;
	    die "FATAL : bad_fastq_format : " if ++$failed > 3;
        }
	print STDERR "line: $line_count\t read: $read_count\r" if ($verbose && ! (($read_count / 4) % 1000));
	$line_count += 4; $read_count++;
        return @data ? \@data : undef;
    };
}
