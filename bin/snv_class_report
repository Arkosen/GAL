#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Set::IntSpan::Fast;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

snv_class_report --class_map refseq2harrison.txt --diff --gff gene_annotations.gff \
		 --ns_expect 0.77 variant_file_list.txt

Description:




Options:

  class_map      Mapping file to use.
  cols	         Comma separate values for columns (id, class) in the
		 mapping file [0,1]
  syn	         Include synonymous SNVs in analysis.  Default is to exclude
		 synonymous SNVs from analysis.
  diff	         Report percent differences from random distribution in classes.
  full           Print report of SNV count for each gene in class.
		 Default is to report raw counts.
  gff            A GFF file to calculating CDS and class footprints which are
		 used to calculate expected variant distribution.
  ns_expect      A real number representing the fraction of changes that would
		 be expected to be non_synonymous based on the genetic code and
		 codon usage for a the genome. If you pass a protein fasta file
		 for the genome the script will calculate the value for you.
		 The default is 0.77
  exclude        A list of classes to exclude from the mapping. [none]


Note: The default ns_expect was calculated as follows:

#/home/bmoore/Projects/10-02-12_Tim_Ley_AML_Genomes/analysis/bin/cgl_protein_codon_usage
perl -lane 'print \$F[-1]' /home/bmoore/Projects/10-02-12_Tim_Ley_AML_Genomes/data/WashU/10-03-01_data/c_snp_classifier/ucsc_kg_refseq/cgl_protein_codon_usage.out | statistics_descrpt
Stats-
mean0.77083062488389

";


my ($help, $map_file, $cols_text, $syn, $diff, $full, $gff, $ns_expect, $exclude);
my $opt_success = GetOptions('help'	   => \$help,
			     'class_map=s' => \$map_file,
			     'cols=s'      => \$cols_text,
			     'syn'         => \$syn,
			     'diff'        => \$diff,
			     'full'        => \$full,
			     'gff=s'       => \$gff,
			     'ns_expect=s' => \$ns_expect,
			     'exclude=s'   => \$exclude,
			     );

die $usage if $help || ! $opt_success;

my $snv_list_file = shift;
die $usage unless -e $map_file && $snv_list_file;

$cols_text ||= '0,1';
my @cols = split /,/, $cols_text;

my $files = parse_list_file($snv_list_file);
my ($id_map, $class_map) = parse_map($map_file, \@cols);

my $class_footprints;
if ($diff || $full) {
    $class_footprints = calculate_footprints($gff, $id_map);
    $ns_expect ||= 0.77;
    $ns_expect = calculate_ns_expect($ns_expect) if -e $ns_expect;
}

my %excludes = map {$_ => 1} split /\s+/, $exclude if $exclude;

my %classes;
my %snv_counts;

for my $file (keys %{$files}) {

    my $subject = $files->{$file}{subject};
    my $format  = $files->{$file}{format};

    open (my $IN, '<', $file) or die
	"Can't open $file for reading\n$!\n";

    while (<$IN>) {
	chomp;
	last if /^\s*\#\#FASTA/;
	next if /^\s*\#/;
	next if /^\s*$/;
	my @effect_id;
	if ($format eq 'gvf') {
	    my ($seqid, $source, $this_type, $start, $end, $score, $strand,
		$phase, $attribute_text) = split /\t/, $_;
	    my %attributes;
	    my @pairs = split /;/, $attribute_text;
	    for my $pair (@pairs) {
		my ($key, $value_text) = split /=/, $pair;
		my @values = split /,/, $value_text;
		$attributes{$key} = \@values;
	    }
	    # my $reference_seq = $attributes{Reference_seq}[0];
	    my $index=0;
	    my %variants; # = map {$index++ => {seq => $_} unless $_ eq $reference_seq} @{$attributes{Variant_seq}};
	    for my $effect_text (@{$attributes{Variant_effect}}) {
		# Variant_effect=non_synonymous_codon:mRNA:RefSeq:NM_001130045:.:0,amino_acid_substitution:polypeptide:RefSeq:NM_001130045:p.G25S:0;
		my ($effect, $type, $db, $id, $desc, $index) = split /:/, $effect_text;
		next unless $type eq 'mRNA';
		push @{$variants{$index}{$effect}}, $id;
	    }
	    for my $index (keys %variants) {
		my ($effect) =  (sort {scalar @{$variants{$index}{$a}} <=> 
				       scalar @{$variants{$index}{$b}}}
				 keys %{$variants{$index}});
		my $id = $variants{$index}{$effect}[0];
		push @effect_id, [$effect, $id];
	    }
	}
	elsif ($format eq 'c_snp') {
	    my ($subj_id, $contig_id, $gene_id, $rna_id, $ucsc_id, $snp_id,
		$c_pos, $class, $allele, $wt_allele, $mut_allele, $wt_aa,
		$mt_aa, $type, $mtx_score, $p_pos, $snp_strand, $trn_strand,
		$multi) = split /\t/, $_;

	    push @effect_id, [$type, $gene_id];
	}
	else {
	    die "Fatal : unknown_format : $format\n";
	}

	for my $effect_id (@effect_id) {
	    my ($effect, $id) = @{$effect_id};
	    
	    if ($effect eq 'not_caught') {
		warn "Warn : type_not_caught : $_\n";
		next;
	    }
	    next if $effect =~ /^synonymous/  && ! $syn;
	    
	    $id = uc $id;

	    my @my_classes = ref $id_map->{$id} ? keys %{$id_map->{$id}} : ();
	    map {$classes{$_}{$subject}{$id}++} @my_classes;
	    $snv_counts{$subject}++;
	}
    }
}

my @subjects = map {$files->{$_}{subject}} sort {$files->{$a}{order} <=> $files->{$b}{order}} keys %{$files};

unless ($full) {
    print join "\t", ('', @subjects);
    print "\n";
}

my @class_names = sort keys %classes;
@class_names = grep {! $excludes{$_}} @class_names if %excludes;

my $cds_footprint = $class_footprints->{ALL_CDS};
for my $class (sort @class_names) {
	print "$class\t";
	for my $subject (@subjects) {
		my $snv_obsv;
		map {$snv_obsv += $classes{$class}{$subject}{$_}} keys %{$classes{$class}{$subject}};
		$snv_obsv ||= 0;

		my $coding_snvs = $snv_counts{$subject};
		my $class_footprint = $class_footprints->{$class};
		my $snv_expect = ($coding_snvs * ($class_footprint / $cds_footprint));
		$snv_expect *= $ns_expect if ! $syn;
		my $pct_diff = $snv_obsv / $snv_expect * 100;
		$pct_diff = sprintf("%.0f", $pct_diff);

		if ($full) {
		    print "\n\t$subject: $snv_obsv / $snv_expect = $pct_diff\n";
		    map {print "\t\t$_: " . $classes{$class}{$subject}{$_} . "\n"} keys %{$classes{$class}{$subject}};
		    print "\n\n";
		}
		elsif ($diff) {
		    print "$pct_diff\t";
		}
		else {
		    print "$snv_obsv\t";
		}
	}
	# my $class_gene_count = keys %{$class_map->{$class}};
	# print "$class_gene_count\n";
	print "\n";
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub parse_map {

    my ($map_file, $cols) = @_;

    open (my $IN, '<', $map_file) or
	die "Can't open $map_file for reading\n$!\n";

    my (%id_map, %class_map);
    while (<$IN>) {
	chomp;
	my ($id, $class);
	my @fields = split /\t/, $_;
	($id, $class) = @fields[@{$cols}];
	$id = uc $id;
	$id_map{$id}{$class}++;
	$class_map{$class}{$id}++;
    }
    return \%id_map, \%class_map;
}

#-----------------------------------------------------------------------------

sub parse_list_file {

    my $file = shift;

    open (my $IN, '<', $file) or
	die "Can't open $file for reading\n$!\n";

    my %files;
    while (<$IN>) {
	next if /^\#/;
	next if /^\s*$/;
	my ($file, $format, $order, $subject) = split /\s+/, $_;
	$files{$file} = {format  => $format,
			 order   => $order,
			 subject => $subject};
    }
    return \%files;
}

#-----------------------------------------------------------------------------

sub calculate_footprints {

    my ($gff, $id_map) = @_;

    open (my $IN, '<', $gff) or die "Can't open $gff for reading\n";

    my %coordinates;
    while (my $line = <$IN>) {
	last if $line =~ /\#\#FASTA/;
	next if $line =~ /^\s*\#/;
	next if $line =~ /^\s*$/;
	my ($seqid, $source, $type, $start, $end, $score, $strand, $phase,
	    $attribute_text) = split /\t/, $line;
	next unless $type eq 'CDS';
	my ($parent) = $attribute_text =~ /Parent=(.*?);/;
	die "Fatal : CDS_has_no_parent : $line\n" unless $parent;

	######################
	######################
	# Temporary Hack !!! #
	$parent =~ s/:mRNA$//;
	######################
	######################

	my @classes = keys %{$id_map->{$parent}};
	push @classes, 'ALL_CDS';
	map {push @{$coordinates{$_}{$seqid}}, ($start, $end)} @classes;
    }

    my %class_footprints;
    for my $class (keys %coordinates) {
	for my $seqid (keys %{$coordinates{$class}}) {
	    my $set = Set::IntSpan::Fast->new();
	    my $these_coordinates = $coordinates{$class}{$seqid};
	    $set->add_range(@{$these_coordinates});
	    $class_footprints{$class} += scalar $set->as_array;
	}
    }
    return \%class_footprints;
}

#-----------------------------------------------------------------------------

sub calculate_ns_expect {



}

#-----------------------------------------------------------------------------
