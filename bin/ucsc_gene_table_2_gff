#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Carp;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

ucsc_gene_table_2_gff --table knownGene

Description:

This script will take knownGene or refGene tables from UCSC and build
GFF files from them.

Options:

  --table   Which UCSC table are you using

            knownGene => knownGene.txt
            refGene   => refGene.txt
	    ccdsGene  => ccdsGene.txt
	    Gencode   => wgEncodeGencodeManualV4.txt
	    vegaGene  => vegaGene
	    ensGene   => ensGene

";


my ($help, $table);
my $opt_success = GetOptions('help'    => \$help,
			     'table=s' => \$table,
			      );

die $usage if $help || ! $opt_success;

my $file = shift;
die $usage unless $file;
open (my $IN, '<', $file) or die "Can't open $file for reading\n$!\n";

my %duplicates;
while (<$IN>) { 
    chomp;
    my ($alignID, $bin, $cdsEnd, $cdsEndStat, $cdsStart,
	$cdsStartStat, $chrom, $exonCount, $exonEnds, $exonFrames,
	$exonStarts, $name, $name2, $proteinID, $score, $strand,
	$txEnd, $txStart);


    if ($table eq 'knownGene') {
	($name, $chrom, $strand, $txStart, $txEnd, $cdsStart, $cdsEnd,
	 $exonCount, $exonStarts, $exonEnds, $proteinID, $alignID) =
	 split /\t/, $_;
    }
    elsif ($table =~ /^(refGene|ccdsGene|Gencode|vegaGene|ensGene)$/) {
	($bin, $name, $chrom, $strand, $txStart, $txEnd, $cdsStart,
	$cdsEnd, $exonCount, $exonStarts, $exonEnds, $score, $name2,
	$cdsStartStat, $cdsEndStat, $exonFrames) = split /\t/, $_;
    }
    else {
	die "FATAL : invalid_format : $table\n";
    }

    carp  "WARN : invalid_strand : $name, $strand"   if $strand  !~ /\+|-/;
    croak "FATAL : invalid_txStart : $name, $txStart" if $txStart !~ /^\d+$/;
    croak "FATAL : invalid_txEnd : $name, $txEnd"     if $txEnd   !~ /^\d+$/;

    my $old_name = $name;
    if (exists $duplicates{$name}) {
	$name = $name . '_DUP_' . sprintf('%02s', $duplicates{$name});
	carp "WARN : duplicate_name : $old_name changed to $name";
    }
    $duplicates{$old_name}++;

    my $transcript = {feature_id => $name,
		      seqid      => $chrom,
		      source     => 'UCSC_' . $table,
		      type       => 'mRNA',
		      start      => $txStart,
		      end        => $txEnd,
		      score      => '.',
		      strand     => $strand,
		      phase      => '.',
		  };
    
    $transcript->{attributes}{ID} = [$name];

    my @aliases = grep {defined $_ } ($name2, $proteinID);
    $transcript->{attributes}{Alias} = \@aliases if scalar @aliases;

    my @exon_starts = split ',', $exonStarts;
    my @exon_ends   = split ',', $exonEnds;
    
    carp "WARN : mis_matched_exon_start_ends : $name\n"
	if (scalar @exon_starts != scalar @exon_ends);

    my @exon_pairs;
    for my $i (0 .. scalar @exon_starts - 1) {
	my ($start, $end) = ($exon_starts[$i], $exon_ends[$i]);
	carp "WARN : negative_length_exon : $name, $start, $end\n" if $start > $end;
	carp "WARN : zero_length_exon : $name, $start, $end\n"     if $start == $end;
	push @exon_pairs, [$start, $end];
    }
    
    carp "WARN : exons_overlap : $name\n" if any_overlaps(@exon_pairs);

    # my @intron_starts;
    # my $intron_ends;
    # map {push @intron_ends, shift @{$_};push @intron_starts, shift @{$_}} @exon_pairs;
    # shift @intron_ends;
    # pop   @intron_starts;
    #
    # my @intron_pairs;
    # while (my ($start, $end) = (shift @intron_starts, shift @intron_ends)) {
    #	carp "WARN : negative_length_intron : $name, $start, $end\n" if $start > $end;
    #	carp "WARN : zero_length_intron : $name, $start, $end\n"     if $start == $end;
    #	push @intron_pairs, [$start, $end];
    # }
    
    my @cds_pairs;
    for my $pair (@exon_pairs) {
	last if $cdsEnd - $cdsStart < 3; #Dont allow a CDS < 3nt long.
	my ($start, $end) = @{$pair};
	next if $end   < $cdsStart;
	last if $start > $cdsEnd;
	$start = $cdsStart if ($start < $cdsStart && $end > $cdsStart);
	$end   = $cdsEnd   if ($start < $cdsEnd && $end > $cdsEnd);
	push @cds_pairs, [$start, $end];
    }

    $transcript->{type} = 'ncRNA' unless scalar @cds_pairs;

    my $exons = build_child_features(parent 	 => $transcript,
				     type   	 => 'exon',
				     coordinates => \@exon_pairs
				     );
    my $CDSs = build_child_features(parent 	 => $transcript,
				    type   	 => 'CDS',
				    coordinates => \@cds_pairs
				    );

    write_gff($transcript, $exons, $CDSs);

}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub build_child_features {

    my %args = @_;

    my $parent = $args{parent};
    my $type   = $args{type};
    my $coords = $args{coordinates};
    my $parent_id = $parent->{feature_id};

    my @features;
    my $count = 1;
    for my $pair (@{$coords}) {
	my ($start, $end) = @{$pair};
	my %feature = %{$parent};
	my $id = join ':', ($parent_id, $type, sprintf('%02s', $count++));
	my $attributes = {ID            => [$id],
			  Parent        => [$parent_id],
			  };

	@feature{qw(type start end attributes)} =
	    ($type, $start, $end, $attributes);
	
	push @features, \%feature;
    }
    return \@features;
}

#-----------------------------------------------------------------------------

sub write_gff {

    my ($transcript, $exons, $CDSs) = @_;

    my @features = ($transcript, @{$exons}, @{$CDSs});

    for my $feature (sort {$a->{start} <=> $b->{start} ||
			   $b->{end}   <=> $a->{end}}  @features) {
	my $attribute_text = get_attribute_text($feature);
	print join "\t", (@{$feature}{qw(seqid source type start end score
					 strand phase)},
			  $attribute_text);
	print "\n";
	print '';
    }
}

#-----------------------------------------------------------------------------

sub get_attribute_text {

    my $feature = shift;
    my $attributes = $feature->{attributes};

    my %ORDER = (ID     => 1,
		 Parent => 2,
		 Alias  => 3,
		 );

    my @pairs;
    for my $key (sort {$ORDER{$a} <=> $ORDER{$b}} keys %{$attributes}) {
	my @values = @{$attributes->{$key}};
	my $value_text = join ',', @values;
	push @pairs, join '=', ($key, $value_text);
    }
    my $attribute_text = join ';', @pairs;
    $attribute_text .= ';';

    return $attribute_text;
}

#-----------------------------------------------------------------------------

sub any_overlaps {

    my @pairs = @_;

    for my $i (0 .. scalar @pairs - 1) {
	my $pair_i = $pairs[$i];
	for my $j (0 .. scalar @pairs - 1) {
	    next if $i == $j;
	    my $pair_j = $pairs[$j];
	    # Return 1 unless these two don't overlap
	    return 1 unless ($pair_i->[1] < $pair_j->[0] or 
			     $pair_i->[0] > $pair_j->[1]); 
	}
    }
    # We never overlaped so return false
    return 0;
}
