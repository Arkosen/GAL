#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use XML::LibXML::Reader;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

dbsnp_libxml_parser --assembly reference ds_chrMT.xml

Description:

This script is a test of XML::LibXML::Reader as a GAL XML parsing module

Options:

  assembly  The assembly that you want the variant locations relative too.

";

# dbSNP subSnpClass to SO mapping
my %TYPE_MAP = ('snp'            => 'SNV',
		'in-del'         => 'sequence_alteration',
		'heterozygous'   => 'sequence_alteration',
		'microsatellite' => 'microsatellite',
		'named-locus'    => 'sequence_alteration',
		'no-variation'   => 'sequence_alteration',
		'mixed'          => 'sequence_alteration',
		'multinucleotide-polymorphism' => 'MNP',
	       );

my ($help, $requested_assembly);
my $opt_success = GetOptions('help'       => \$help,
			     'assembly=s' => \$requested_assembly,
			    );

die $usage if $help || ! $opt_success;

my $file = shift;
die $usage unless $file;

my $reader = new XML::LibXML::Reader(location => $file)
	 or die "Can not read $file\n";


while (my $rs_data = get_next_rs($reader)) {

	my $features = build_features($rs_data);

	for my $feature (@{$features}) {
		my $gvf_line = rs2gvf($feature);
		print "$gvf_line\n";
		print '';
	}
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub get_next_rs {

	my $reader = shift;

	$reader->nextElement('Rs');
	my $rs = XML::LibXML::Reader::copyCurrentNode($reader, 1);

	return undef unless $rs;

	# Rs keys:
	# qw(rsId snpClass snpType molType validProbMin validProbMax
	#    genotype bitField)
	my $rs_data = get_attributes($rs);

	my @ss_set = $rs->getChildrenByLocalName('Ss');

	for my $ss (@ss_set) {

		# Ss keys:
		# qw(ssId handle batchId locSnpId subSnpClass orient
		#    strand molType buildId methodClass validated
		#    linkoutUrl);
		my $ss_data = get_attributes($ss);

		my ($sequence) = $ss->getChildrenByLocalName('Sequence');
		my ($observed) = $sequence->getChildrenByLocalName('Observed');
		my $alleles = $observed->textContent;
		my @alleles = split m|/|, $alleles;
		$ss_data->{alleles} = \@alleles;
		push @{$rs_data->{ss_set}}, $ss_data;
	}

	my ($assembly) = grep {$_->getAttribute('groupLabel') eq $requested_assembly}
	  $rs->getChildrenByLocalName('Assembly');

	# Assembly keys:
	# qw(dbSnpBuild genomeBuild groupLabel assemblySource
	#    current reference);
	my $assembly_data = get_attributes($assembly);

	my @component_set = $assembly->getChildrenByLocalName('Component');

	for my $component (@component_set) {

		# Component keys:
		# qw(componentType ctgID accession name chromosome start end
		#    orientation gi groupTerm contigLable)
		my $component_data = get_attributes($component);

		my @map_loc_set = $component->getChildrenByLocalName('MapLoc');

		for my $map_loc (@map_loc_set) {

			# MapLoc keys:
			# qw(asnFrom asnTo locType alnQuality orient
			#    physMapInt leftFlankNeighborPos
			#    rightFlankNeighborPos leftContigNeighborPos
			#    rightContigNeighborPos numberOfMismatches
			#    numberOfDeletions numberOfInsertions);

			my $map_loc_data = get_attributes($map_loc);

			push @{$component_data->{map_loc_set}}, $map_loc_data;
			#		my $ctg_start = $map_loc->getAttribute('asnFrom');
			#		my $ctg_end   = $map_loc->getAttribute('asnTo');
			#		my $chr_start = $map_loc->getAttribute('physMapInt') + 1;
		}
		push @{$assembly_data->{component_set}}, $component_data;
	}

	$rs_data->{assembly}  = $assembly_data;

	return $rs_data;
}

#-----------------------------------------------------------------------------

sub get_attributes {

	my $element = shift;

	my @attribute_set = $element->attributes;
	my %attributes;
	for my $attribute (@attribute_set) {
		next if (ref($attribute) ne 'XML::LibXML::Attr');
		my $name  = $attribute->localName;
		my $value = $attribute->value;
		$attributes{$name} = $value;
	}
	return \%attributes;
}

#-----------------------------------------------------------------------------

sub rs2gvf {

	my $feature = shift;

	my $attribute_txt = build_att_txt($feature);

	my $gvf_line =  join "\t", (@{$feature}{qw (seqid source type start
						    end score strand phase)},
				    $attribute_txt
				   );
	return $gvf_line;
}

#-----------------------------------------------------------------------------

sub build_features {

	my $rs = shift;

	my $Dbxref = 'dbSNP:rs' . $rs->{rsId};
	my @rs_errors;
	@rs_errors = @{$rs->{errors}} if (ref($rs->{errors}) eq 'ARRAY');
	my $assembly = $rs->{assembly};

	# Rs keys:
	# qw(rsId snpClass snpType molType validProbMin validProbMax
	#    genotype bitField)

	# Ss keys:
	# qw(ssId handle batchId locSnpId subSnpClass orient
	#    strand molType buildId methodClass validated
	#    linkoutUrl);

	# Assembly keys:
	# qw(dbSnpBuild genomeBuild groupLabel assemblySource
	#    current reference);

	# Component keys:
	# qw(componentType ctgID accession name chromosome start end
	#    orientation gi groupTerm contigLable)

	# MapLoc keys:
	# qw(asnFrom asnTo locType alnQuality orient physMapInt
	#    leftFlankNeighborPos rightFlankNeighborPos
	#    leftContigNeighborPos rightContigNeighborPos
	#    numberOfMismatches numberOfDeletions numberOfInsertions);

	my @features;
	for my $ss (@{$rs->{ss_set}}) {

		my ($alleles, $ssId, $handle, $locSnpId, $subSnpClass) =
		  @{$ss}{qw(alleles ssId handle locSnpId subSnpClass)};

		$ssId = 'ss' . $ssId;

		my $type = $TYPE_MAP{$subSnpClass}
		  || 'sequence_alteration';

		my @ss_errors;
		@ss_errors = @{$ss->{errors}}
		  if (ref($ss->{errors}) eq 'ARRAY');

		my $feature_count;
		for my $component (@{$assembly->{component_set}}) {
			my $int_feat   = 'RefSeq:' . $component->{accession};
			my $chromosome = 'chr' . $component->{chromosome};
			my $ctg_start  = $component->{start};
			my $ctg_end    = $component->{end};
			my @component_errors;
			@component_errors = @{$component->{errors}}
			  if (ref($component->{errors}) eq 'ARRAY');

		      MAP_LOC:
			for my $map_loc (@{$component->{map_loc_set}}) {

				my ($asnFrom, $asnTo, $physMapInt, $alnQuality) =
				  @{$map_loc}{qw(asnFrom asnTo physMapInt alnQuality)};

				next MAP_LOC unless (defined $asnFrom &&
						     defined $asnTo   &&
						     defined $ctg_start);

				my $start = $asnFrom + $ctg_start + 1;
				my $end   = $asnTo   + $ctg_start + 1;

				my $ss_strand  = $ss->{orient}
				  eq 'forward' ? 1 : -1;
				my $ctg_strand = $component->{orientation}
				  eq 'fwd'     ? 1 : -1;
				my $rs_strand  = $map_loc->{orient}
				  eq 'forward' ? 1 : -1;

				my $strand = $ss_strand * $ctg_strand * $rs_strand;
				$strand = $strand == 1 ? '+' : '-';

				my @map_loc_errors;
				@map_loc_errors = @{$map_loc->{errors}}
				  if (ref($map_loc->{errors}) eq 'ARRAY');

				my @errors = (@rs_errors, @ss_errors,
					      @component_errors,
					      @map_loc_errors);

				my %attributes =
				  (ID                  => [$ssId],
				   Variant_seq         => $alleles,
				   Alias	       => [$locSnpId],
				   Intersected_feature => [$int_feat],
				   Dbxref              => [$Dbxref],
				   dbSNP_handle        => [$handle],
				   dbSNP_alnQuality    => [$alnQuality],
				   Errors              => \@errors,
				  );

				delete $attributes{Errors}
				  unless scalar @{$attributes{Errors}};

				my $feature = {feature_id => $ssId,
					       seqid      => $chromosome,
					       source     => 'dbSNP',
					       type       => $type,
					       start      => $start,
					       end        => $end,
					       score      => '.',
					       strand     => $strand,
					       phase      => '.',
					       attributes => \%attributes,
					      };

				push @features, $feature;
				$feature_count++;
			}
		}
		if ($feature_count > 1) {
			warn "Error : rs_id_not_uniqe : $ssId\n";
		}
	}
	return \@features;
}

#-----------------------------------------------------------------------------

sub build_att_txt {

	my $feature = shift;

	my %order = (ID                  => 1,
		     Variant_seq         => 2,
		     Alias	 => 3,
		     Dbxref              => 4,
		     Intersected_feature => 5,
		     dbSNP_handle        => 6,
		     dbSNP_alnQuality    => 7,
		     Errors              => 8,
		    );

	my %attributes = %{$feature->{attributes}};

	my $attribute_txt;
	for my $key (sort {$order{$a} <=> $order{$b}} keys %attributes) {

		my @values = @{$attributes{$key}};
		my $value_txt = join ',', @values;
		$attribute_txt .= "$key=$value_txt;";
	}
	return $attribute_txt;
}
