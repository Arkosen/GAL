#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Datastore::MD5;
use URI::Escape;
use DBI;
use CGL::Annotation;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

snp2gene_leppert --datastore datastore.index --format gff3
                 --dsn dbi:mysql:db_name --user user_name
                 --passwd password

Description:

This script will list all snps associated with a give gene.

Options:

  datastore  The datastore index file for the gene datastore.
  format     The format of the GFF3 file.
  dsn        The DBI connection string [dbi:mysql:database=pcode]
  user       The user to connect to the database as [bmoore]
  password   The password to connect to the database with ['']
  continue   Will not rewrite existing .snp files.  This allow you
             to continue a previously aborted run.  No validation is
             done to ensure that previous files were not corrupted in
             any previous run failure.

";

my ($help, $ds_index_file, $format, $dsn, $user, $psswd, $continue);
my $opt_success = GetOptions('help'        => \$help,
			     'datastore=s' => \$ds_index_file,
			     'format=s'    => \$format,
			     'dsn=s'       => \$dsn,
			     'user=s'      => \$user,
			     'psswd=s'     => \$psswd,
			     'continue'    => \$continue,
			      );

die $usage if ( $help          ||
		! $opt_success ||
		! $format
	      );

$dsn    ||= 'dbi:mysql:database=leppert_snp';
$user   ||= 'bmoore';
$psswd  ||= '';

my $dbh     = DBI->connect($dsn, $user, $psswd);
my $sth_snp = $dbh->prepare('SELECT subj_id, snp_id, start, allele FROM snp WHERE contig_id = ? AND start >= ? AND start <= ?');

my $ds = parse_datastore($ds_index_file);

for my $gene_id (keys %{$ds}) {

	my ($gff_file, $fasta_file);
	$gff_file = $ds->{$gene_id};

	($fasta_file = $gff_file)   =~ s/\.gff3?$/.fasta/;

	my $cgl  = CGL::Annotation->new(format     => $format,
					gff_file   => $gff_file,
					fasta_file => $fasta_file,
				       );

	my $contig = $cgl->contig(0);
        my $genes  = $cgl->genes();
	my $gene   = shift @{$genes};

	my $ctg_name 	= $contig->id;
	my ($ctg_id, $ctg_begin, $ctg_end) = split /:/, $ctg_name;
	($ctg_begin, $ctg_end) = ($ctg_end, $ctg_begin) if $ctg_begin > $ctg_end;

	my $gene_id     = $gene->id;
	my $gene_begin  = $gene->nbeg;
	my $gene_end    = $gene->nend;
	my $gene_strand = $gene->strand;
	my $gene_length = abs($gene_begin - $gene_end);

	my ($gene_5p_end, $gene_3p_end);
	if ($gene_strand == 1) {
		$gene_5p_end = $ctg_begin + $gene_begin;
		$gene_3p_end = $gene_5p_end + $gene_length;
	}
	elsif ($gene_strand == -1) {
		$gene_3p_end = $ctg_end - $gene_begin;
		$gene_5p_end = $gene_3p_end - $gene_length;
	}
	else {
		die "Bad gene strand: $gene_strand\n";
	}

	my $subjects = $dbh->selectall_hashref($sth_snp, [qw(subj_id snp_id)], {}, ($ctg_id, $ctg_begin + 499, $ctg_end - 499));

	for my $subj_id (keys %{$subjects}) {

		my $snp_file;
		($snp_file   = $gff_file)   =~ s/\.gff3?$/_$subj_id.snp/;

		if ($continue && -e $snp_file) {
			print STDERR "Continue\t$gene_id\t$subj_id\t\n";
			next;
		}

		open (my $SNP, '>', $snp_file) or
		  die "Can't open $snp_file for writing\n";
		print STDERR "Wrote\t$gene_id\t$subj_id\t\n";

		my $subject = $subjects->{$subj_id};
		for my $snp_id (keys %{$subject}) {

			my $snp = $subject->{$snp_id};

			print $SNP join "\t", ($subj_id,
					       $ctg_id,
					       $gene_id,
					       $snp->{snp_id},
					       $snp->{start},
					       $snp->{allele},
					       '.',
					       '+',
					      );
			print $SNP "\n";
		}
		close $SNP;
	}
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------
sub parse_datastore {
	my $ds_index = shift;

	open (my $IN, '<', $ds_index);

	my %index;
	while (<$IN>) {
		chomp;
		my ($key, $value) = split /\t/, $_;
		$index{$key} = $value;
	}
	return \%index;
}
