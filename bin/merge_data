#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

merge_data  --col1 1 --col2 0 data1.txt data2.txt

# Merge GFF3 files on feature coordinates
merge_data  --col1 0,3,4 --col2 0,3,4 data1.gff3 data2.gff3

# As above by print only the attributes of the second GFF3 file
merge_data  --col1 0,3,4 --col2 0,3,4 --pcol2 8 data1.gff3 data2.gff3

Description:

Merge together the data from two files based on a shared ID columns;

Options:

  col1: The ID column(s) in the 1st data file (use comma separated
        list for multiple column keys).

  col2: The ID column in the 2nd data file (use comma separated
        list for multiple column keys).

  split: The charachter to split columns on.

  pcol1: The columns to print from file 1 (defaults to all).

  pcol1: The columns to print from file 2 (defaults to all).

";


my ($help, $col1, $col2, $split, $pcol1, $pcol2);
my $opt_success = GetOptions('help'    => \$help,
			     'col1=s'  => \$col1,
			     'col2=s'  => \$col2,
			     'split=s' => \$split,
			     'pcol1=s' => \$pcol1,
			     'pcol2=s' => \$pcol2,
			      );

$split ||= "\t";
$split = qr|$split|;

die $usage if $help || ! $opt_success;

my ($file1, $file2) = @ARGV;
die $usage unless $file1 && $file2;

$col1 ||= 0;
$col2 ||= 0;

my @cols1 = split /,/, $col1;
my @cols2 = split /,/, $col2;
my @pcols1;
@pcols1 = split /,/, $pcol1 if $pcol1;
my @pcols2;
@pcols2 = split /,/, $pcol2 if $pcol2;

my $index = parse_file(\@cols1, $file1);

open (my $IN, '<', $file2) or die "Can't open $file2 for reading\n$!\n";

while (<$IN>) {

	chomp;
	my @columns2 = split /$split/, $_;
	my $key = join ':', @columns2[@cols2];
	next unless $index->{$key};
	my $column1_set = $index->{$key};
	for my $columns1 (@{$column1_set}) {
	  my @print_columns1 = @pcols1 ? @{$columns1}[@pcols1] : @{$columns1};
	  my @print_columns2 = @pcols2 ? @columns2[@pcols2] : @columns2;
		print join "\t", (@print_columns1, @print_columns2);
		print "\n";
	}

}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub parse_file {

	my ($cols1, $file1) = @_;

	open (my $IN, '<', $file1) or die "Can't open $file1 for reading\n$!\n";

	my %index_hash;
	while (<$IN>) {
		chomp;
		my @columns1 = split /$split/, $_;
		my $key = join ':', @columns1[@{$cols1}];
		push @{$index_hash{$key}}, \@columns1;
	}
	return \%index_hash;
}
