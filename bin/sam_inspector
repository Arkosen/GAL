#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Set::IntSpan::Fast;
use Statistics::Descriptive;
use Text::Graph;
use Text::Graph::DataSet;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

sam_inspector alignments.sam

Description:

This script provides simple line-by-line access to SAM/BAM files.  It allows
you do do simple filtering and reporting on the files.  Access to BAM files
requires that samtools in installed and in the current PATH.

Options:

  --summary    Print a summary of the SAM file

  --filter     Filter the SAM file based on some criteria

  --clean      Remove invalid lines such as those that have an unmapped
	       flag and yet still have a mapping quality because bwa mapped
	       them off the end of the reference.

  --region     Limit analysis to a region by passing a region to samtools
	       view.  This only works on indexed BAM files.

  --bam        Output is in BAM format

  --headers    Print headers with output

  --intervals  Print a list of intervals where there is any coverage

";


my ($help, $summary, $filter, $clean, $region, $bam, $headers,
    $intervals);

my $opt_success = GetOptions('help'       => \$help,
			     'summary'    => \$summary,
			     'filter=s'   => \$filter,
			     'clean'      => \$clean,
			     'region=s'   => \$region,
			     'bam'        => \$bam,
			     'headers'    => \$headers,
			     'intervals'  => \$intervals,
			     );

die $usage if $help || ! $opt_success;

$region ||= '';

my %HEADERS;

my $PAIRED        = 0x0001; # 1
my $PAIR_MAPPED   = 0x0002; # 2
my $UNMAPPED      = 0x0004; # 4
my $MATE_UNMAPPED = 0x0008; # 5
my $REVERSE       = 0x0010; # 16
my $MATE_REVERSE  = 0x0020; # 32
my $FIRST_READ    = 0x0040; # 64
my $SECOND_READ   = 0x0080; # 128
my $NOT_PRIMARY   = 0x0100; # 256
my $FAILS         = 0x0200; # 512
my $DUPLICATE     = 0x0400; # 1024

my @files = @ARGV;

die $usage unless ! grep {-r @_} @files;

if ($summary) {
    build_summary(\@files);
}
elsif ($clean) {
    clean_file(\@files);
}
elsif ($intervals) {
    calc_intervals(\@files);
}
else {
    print_file(\@files);
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub build_summary {

    my $files = shift;

    my %sets;
    my $isizes = Statistics::Descriptive::Sparse->new();
    my $lengths = Statistics::Descriptive::Sparse->new();

    my $count;
    my %mapped_length;
    my $unmapped_length;
    my %raw_flags;
    my %flags;
    my %qnames;
    my %rnames;
    my %mapqs;

    my $bar_graph = Text::Graph->new('Bar', maxlen => 50, showval => 1);

    for my $file (@{$files}) {
	my $iterator = make_iterator($file, $region);

	while (my $a = &{$iterator}) {
	    $count++;
	    my ($qname, $flag, $rname, $pos, $mapq, $cigar, $mrnm,
		$mpos, $isize, $seq, $qual, $opt)
		=
		@{$a}{qw(qname flag rname pos map cigar mrnm mpos
			 isize seq qual opt)};
	    
	    $qnames{$qname}++;
	    $raw_flags{$flag}++;
	    ($flag & $PAIRED)        && $flags{paired}++;
	    ($flag & $PAIR_MAPPED)   && $flags{pair_mapped}++;
	    ($flag & $UNMAPPED)      && $flags{unmapped}++;
	    ($flag & $MATE_UNMAPPED) && $flags{mate_unmapped}++;
	    ($flag & $REVERSE)       && $flags{reverse}++;
	    ($flag & $MATE_REVERSE)  && $flags{mate_reverse}++;
	    ($flag & $FIRST_READ)    && $flags{first_read}++;
	    ($flag & $SECOND_READ)   && $flags{second_read}++;
	    ($flag & $NOT_PRIMARY)   && $flags{not_primary}++;
	    ($flag & $FAILS)	 && $flags{fails}++;
	    ($flag & $DUPLICATE)     && $flags{duplicate}++;
	    
	    $mapped_length{$rname} += $a->{length} unless ($flag & $UNMAPPED);
	    $mapped_length{$rname} += $a->{length} if ($flag & $PAIR_MAPPED);
	    
	    $rnames{$rname}++;
	    $sets{$rname} ||= Set::IntSpan::Fast->new();
	    $sets{$rname}->add_range($pos, $pos + $a->{length} - 1) if $pos;
	    $sets{$rname}->add_range($mpos, $mpos + $a->{length} - 1) if $mpos;
	    $mapqs{$mapq}++;
	    $isizes->add_data($isize) if $isize;
	    $lengths->add_data($a->{length});
	}
    }
    my %coverage;
    for my $rname (keys %sets) {
	my $iter = $sets{$rname}->iterate_runs();
	while (my ( $start, $end ) = $iter->()) {
	    $coverage{$rname} += ($end - $start + 1);
	}
    }
    my $total_coverage;
    map {$total_coverage += $_} values %coverage;

    my $total_mapped_length;
    map {$total_mapped_length += $_} values %mapped_length;

    my %depth;
    for my $rname (keys %mapped_length) {
	$depth{$rname} = $coverage{$rname} / $mapped_length{$rname};
    }

    print "TOTAL ALIGNMENTS:  $count\n\n";
    print "TOTAL LENGTH:  " . $lengths->sum . "\n\n";
    print "MAPPED LENGTH:  $total_mapped_length\n\n";
    print "QNAMES:  " . (scalar keys(%qnames)) . "\n\n";

    print "RNAMES:\n";
    print $bar_graph->to_string(\%rnames,
				sort =>
				sub {sort {my ($x) = ($a =~ /(\d+)/) || 99;
					   my ($y) = ($b =~ /(\d+)/) || 99;
					   $x <=> $y || $a cmp $b} @_});
    print "\n";

    print "Coverage:\n";
    print $bar_graph->to_string(\%coverage,
				sort =>
				sub {sort {my ($x) = ($a =~ /(\d+)/) || 99;
					   my ($y) = ($b =~ /(\d+)/) || 99;
					   $x <=> $y || $a cmp $b} @_});
    print "\n";

    print "Mapped Length:\n";
    print $bar_graph->to_string(\%mapped_length,
				sort =>
				sub {sort {my ($x) = ($a =~ /(\d+)/) || 99;
					   my ($y) = ($b =~ /(\d+)/) || 99;
					   $x <=> $y || $a cmp $b} @_});
    print "\n";

    print "Depth of Coverage:\n";
    print $bar_graph->to_string(\%depth,
				sort =>
				sub {sort {my ($x) = ($a =~ /(\d+)/) || 99;
					   my ($y) = ($b =~ /(\d+)/) || 99;
					   $x <=> $y || $a cmp $b} @_});
    print "\n";

    print "TOTAL COVERAGE:  $total_coverage\n\n";
    print "AVERAGE DEPTH COVERAGE:  " . sprintf("%.2f", $total_mapped_length / $total_coverage) . "\n\n";
    print "FLAGS:\n";
    print $bar_graph->to_string(\%flags, [qw(paired pair_mapped
					     unmapped mate_unmapped
					     reverse mate_reverse
					     first_read second_read
					     not_primary fails
					     duplicate)]);

    print "\n\n";
    print "MAPQ:\n";
    print $bar_graph->to_string(\%mapqs, sort => sub {sort {$a <=> $b} @_});
    print "\n\n";
    print '';
}

#-----------------------------------------------------------------------------

sub apply_filter {

    my $a = shift;

    # QNAME  Query (pair) NAME
    # FLAG   bitwise FLAG
    # RNAME  Reference sequence NAME
    # POS    1-based leftmost POSition/coordinate of clipped sequence
    # MAP    QMAPping Quality (Phred-scaled)
    # CIGAR  extended CIGAR string
    # MRNM   Mate Reference sequence NaMe (‘=’ if same as RNAME)
    # MPOS   1-based Mate POSistion
    # ISIZE  Inferred insert SIZE
    # SEQ    query SEQuence on the same strand as the reference
    # QUAL   query QUALity (ASCII-33 gives the Phred base quality)
    # OPT    variable OPTional fields in the format TAG:VTYPE:VALUE

    my $o = $a->{opts};

    my $return_value = eval $filter;
    die "Fatal Error in code ref: $filter\n$@\n" if $@;

    return $return_value;
}

#-----------------------------------------------------------------------------

sub clean_file {

    my $file = shift;

    my $iterator = make_iterator($file, $region);

    while (my $a = &{$iterator}) {
	next if (($a->{flag} & $UNMAPPED) && ($a->{map} != 0 || $a->{cigar} ne '*'));
	print_alignment($a);
    }
}

#-----------------------------------------------------------------------------

sub calc_intervals {

    my $files = shift;

    my %intervals;

    for my $file (@{$files}) {
	my $iterator = make_iterator($file, $region);
	while (my $a = &{$iterator}) {
	    my $rname = $a->{rname};
	    my $pos   = $a->{pos};
	    my $mpos  = $a->{mpos};
	    $intervals{$rname} ||= Set::IntSpan::Fast->new();
	    $intervals{$rname}->add_range($pos, $pos + $a->{length} - 1) if $pos;
	    $intervals{$rname}->add_range($mpos, $mpos + $a->{length} - 1) if $mpos;
	}
    }
    for my $rname (keys %intervals) {
	my $iter = $intervals{$rname}->iterate_runs();
	while (my ( $start, $end ) = $iter->()) {
	    print join "\t", ($rname, $start, $end);
	    print "\n";
	}
    }
}

#-----------------------------------------------------------------------------

sub print_alignment {

    my $a = shift;

    my @opts = ();
    if (ref $a->{opt} eq 'HASH') {
	my $opts = $a->{opt};
	for my $key (keys %{$opts}) {
	    push @opts, join ':', ($key, @{$opts->{$key}}{qw(type value)});
	}
    }
    else {
	@opts = @{$a->{opt}};
    }
    print join "\t", (@{$a}{qw(qname flag rname pos map cigar mrnm mpos isize
			      seq qual)}, @opts);
    print "\n";
}

#-----------------------------------------------------------------------------

sub print_file {

    my $file = shift;

    my $iterator = make_iterator($file, $region);

    while (my $a = &{$iterator}) {
	print_alignment($a);
    }



}

#-----------------------------------------------------------------------------

sub make_iterator {

    my ($file, $region, $options) = @_;

    $file = "samtools view $region $file |" if $file =~ /\.bam$/;
    my $IN;
    if ($file eq '-') {
    	open ($IN, "<&=STDIN") or die "FATAL : cant_open_STDIN :\n";
    }
    else {
    	open ($IN, $file) or
    	    die "FATAL : cant_open_file_for_reading : $file\n";
    }

    return
	sub {
	  LINE:
	    while (my $line  = <$IN>) {
		chomp $line;
		if ($line =~/^@/) {
		    if ($headers) {
			print "$line\n";
		    }
		    my ($head_tag, $pair_text) = split /\s+/, $line;
		    my @pairs = split /\s+/, $pair_text;
		    for my $pair (@pairs) {
			my ($key, $value) = split /:/, $pair;
			$HEADERS{$head_tag}{$key} = $value;
		    }
		    next LINE;
		}
		# QNAME  Query (pair) NAME
		# FLAG   bitwise FLAG
		# RNAME  Reference sequence NAME
		# POS    1-based leftmost POSition/coordinate of clipped sequence
		# MAP    QMAPping Quality (Phred-scaled)
		# CIGAR  extended CIGAR string
		# MRNM   Mate Reference sequence NaMe (‘=’ if same as RNAME)
		# MPOS   1-based Mate POSistion
		# ISIZE  Inferred insert SIZE
		# SEQ    query SEQuence on the same strand as the reference
		# QUAL   query QUALity (ASCII-33 gives the Phred base quality)
		# OPT    variable OPTional fields in the format TAG:VTYPE:VALUE
		my %alignment;
		my @opts;
		(@alignment{qw(qname flag rname pos map cigar mrnm mpos isize seq qual)}, @opts) = split /\t/, $line;
		if ($options) {
		    my %opts;
		    my $opt_text = $alignment{opt};
		    my @opt_pairs = split /\t/, $opt_text;
		    for my $opt_pair (@opt_pairs) {
			my ($tag, $type, $value) = split /:/, $opt_pair;
			$opts{$tag}{value} = $value;
			$opts{$tag}{type} = $type;
		    }
		    $alignment{opt} = \%opts;
		}
		else {
		    $alignment{opt} = \@opts;
		}
		$alignment{length} = (length $alignment{seq}) - 1;
		if ($filter) {
		    next LINE unless apply_filter(\%alignment);
		}
		return %alignment ? \%alignment : undef;
	    }
	}
}

#-----------------------------------------------------------------------------
