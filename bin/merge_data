#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

merge_data  --col1 1 --col2 0 data1.txt data2.txt

# Merge GFF3 files on feature coordinates
merge_data  --col1 0,3,4 --col2 0,3,4 data1.gff3 data2.gff3

# As above by print only the attributes of the second GFF3 file
merge_data  --col1 0,3,4 --col2 0,3,4 --pcol2 8 data1.gff3 data2.gff3

Description:

Merge together the data from two files based on a shared ID columns;

Options:

  --col1

    The ID column(s) in the 1st data file (use comma separated list
    for multiple column keys).

  --col2

    The ID column in the 2nd data file (use comma separated list for
    multiple column keys).

  --split, -s

    The charachter to split columns on.

  --pcol1

    The columns to print from file 1 (defaults to all).

  --pcol2

    The columns to print from file 2 (defaults to all).

  --uniq, -u

    Ensure that output lines are unique.

";


my ($help, $col1, $col2, $split, $pcol1, $pcol2, $print_uniq);
my $opt_success = GetOptions('help'      => \$help,
			     'col1=s'    => \$col1,
			     'col2=s'    => \$col2,
			     'split|s=s' => \$split,
			     'pcol1=s'   => \$pcol1,
			     'pcol2=s'   => \$pcol2,
			     'uniq|u'    => \$print_uniq,
			      );

die $usage if ! $opt_success;

if ($help) {
  print $usage;
  exit(0);
}

$split ||= "\t";
$split = qr|$split|;

my ($file1, $file2) = @ARGV;
die $usage unless $file1 && $file2;

$col1 ||= 0;
$col2 ||= 0;

my @cols1 = split /,/, $col1;
my @cols2 = split /,/, $col2;
my @pcols1;
@pcols1 = split /,/, $pcol1 if defined $pcol1;
my @pcols2;
@pcols2 = split /,/, $pcol2 if defined $pcol2;

my $index = parse_file(\@cols1, $file1);

open (my $IN, '<', $file2) or die "Can't open $file2 for reading\n$!\n";

my %uniq;
while (<$IN>) {

	chomp;
	my @columns2 = split /$split/, $_;
	my $key = join ':', @columns2[@cols2];
	next unless $index->{$key};
	my @print_columns2 = @pcols2 ? @columns2[@pcols2] : @columns2;
	my $column1_set = $index->{$key};
      SET:
	for my $columns1 (@{$column1_set}) {
	  my @print_columns1 = @pcols1 ? @{$columns1}[@pcols1] : @{$columns1};
	  my $output = join "\t", (@print_columns1, @print_columns2);
	  next SET if $print_uniq && $uniq{$output}++;
	  print "$output\n";
	}
}

exit(0);

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub parse_file {

	my ($cols1, $file1) = @_;

	open (my $IN, '<', $file1) or die "Can't open $file1 for reading\n$!\n";

	my %index_hash;
	while (<$IN>) {
		chomp;
		my @columns1 = split /$split/, $_;
		my $key = join ':', @columns1[@{$cols1}];
		push @{$index_hash{$key}}, \@columns1;
	}
	return \%index_hash;
}
