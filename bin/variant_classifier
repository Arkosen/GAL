#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use GAL::Annotation;
use IO::Prompt;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

variant_classifier --create --parser gff3 --storage SQLite           \
                   --fasta path/to/fasta                             \
                   --feature_dsn 'dbi:SQLite:dbname=feature.sqlite'  \
                   --variant_dsn 'dbi:SQLite:variant.sqlite'         \
                   genome_annotation.gff3 variants.gvf

Description:

This script will take a genome annotation file, a variant file and classify
the functional effects of the variants against mRNA annotations.

Options:

  create       Only create and load the databases then die.
	       to add to  the existing database if it exists.
  parser       The format of the input file (a subclass of GAL::Parser).
  storage      The type of storage to use (a sublcass of GAL::Storage).
  fasta        A path to the fasta files associated with the give features.
  feature_dsn  The DBI connection string (e.g. dbi:mysql:database) for the
	       features
  variant_dsn  The DBI connection string (e.g. dbi:mysql:database) for the
	       variants.
  user         The database user.  Defaults first to \$ENV{\${driver}_user}
	       where \$driver is the driver parsed from the dsn. ['']
  password     The database password.   Defaults first to
	       \$ENV{\${driver}_password} where \$driver is the driver
	       parsed from the dsn.
  prompt       Prompt for the password on the command line.

";

my ($help, $create, $parser, $storage, $fasta, $feature_dsn, $variant_dsn, $user,
    $password, $prompt);
my $opt_success = GetOptions('help'          => \$help,
			     'create'        => \$create,
			     'parser=s'      => \$parser,
			     'storage=s'     => \$storage,
			     'fasta=s'       => \$fasta,
			     'feature_dsn=s' => \$feature_dsn,
			     'variant_dsn=s' => \$variant_dsn,
			     'user=s'        => \$user,
			     'password=s'    => \$password,
			     'prompt'        => sub {$password = prompt("Password: ", -tty,  -echo => '*')->{value}},
			      );

die $usage if $help || ! $opt_success;

die $usage unless $feature_dsn && $variant_dsn;

my ($feature_file, $variant_file) = @ARGV;

my $feat_store_args = {class    => $storage,
		       dsn      => $feature_dsn,
		       user     => $user,
		       password => $password,
                   };

my $var_store_args = {class    => $storage,
		      dsn      => $variant_dsn,
		      user     => $user,
		      password => $password,
		     };

my $parser_args = {class => $parser,
                  };

my $feat_store = GAL::Annotation->new(storage => $feat_store_args,
				      parser  => $parser_args,
				      fasta   => $fasta,
				     );

my $var_store = GAL::Annotation->new(storage => $var_store_args,
				     parser  => $parser_args,
				     fasta   => $fasta,
				    );

if ($create) {
  $feat_store->load_files(files => $feature_file,
			  mode  => 'overwrite',
			 );
  $var_store->load_files(files => $variant_file,
			 mode  => 'overwrite',
			);
  die;
}

my $features = $feat_store->schema->resultset('Feature');
my $variants = $var_store->schema->resultset('Feature');
# my $atts =     $var_store->schema->resultset('Attribute');

my $mrnas = $features->search({type => 'mRNA'});
while (my $mrna = $mrnas->next) {
  my $mrna_id = $mrna->feature_id;
  my $CDSs = $mrna->CDSs;
  while (my $CDS = $CDSs->next) {
    my $bins = $CDS->get_feature_bins;
    my $start = $CDS->start;
    my $end   = $CDS->end;
    my %where = (bin   => {'-in' => $bins},
		 start => {'>='  => $start},
		 end   => {'<='  => $end},
		);
    my $snvs = $variants->search(\%where); # ->cursor

    while (my $snv = $snvs->next) { # @snv
      my $snv_id = $snv->feature_id;
      my $start  = $snv->start;
      my $reference_seq = $snv->reference_seq;
      my @variant_seqs  = $snv->variant_seq_no_ref;

      ###########################################################################
      # User cursors instead of objects for a bit of a speed up.
      ###########################################################################
      #
      #my ($snv_id, $start) = @snv[1, 5];
      #my $att_where = {feature_id => $snv_id,
      #		       att_key    => {'-in' => [qw(Reference_sequence
      #						   Variant_sequence)]}
      #		      };
      #my %attributes;
      #my $atts = $atts->search($att_where)->cursor;
      #while (my @att = $atts->next) {
      #	push @{$attributes{$att[3]}}, $att[4];
      #}
      #my $reference_seq = $attributes{Reference_seq}[0];
      #my @variant_seqs = grep {$_ ne $reference_seq} @{$attributes{Variant_seq}};
      #
      ###########################################################################

      for my $variant_seq (@variant_seqs) {
	my $mrna_variant_seq = $variant_seq;
	$mrna_variant_seq = $mrna->annotation->revcomp($variant_seq)
	  if $mrna->strand eq '-';
	my ($ref_codon, $offset) = $mrna->codon_at_location($start);
	my $ref_aa = $mrna->annotation->translate($ref_codon);
	my $var_codon = $ref_codon;
	substr($var_codon, $offset, 1, $mrna_variant_seq);
	my $var_aa = $mrna->annotation->translate($var_codon);
	my $effect;
	if ($ref_aa eq $var_aa) {
	  $effect = 'synonymous_codon';
	}
	elsif ($ref_aa eq '*') {
	  $effect = 'stop_lost';
	}
	elsif ($var_aa eq '*') {
	  $effect = 'stop_gained';
	}
	else {
	  $effect = 'non_synonymous_codon';
	}
	print join "\t", ($mrna_id,
			  $snv_id,
			  $reference_seq,
			  $variant_seq,
			  $ref_codon,
			  $var_codon,
			  $ref_aa,
			  $var_aa,
			  $effect,
			 );
	print "\n";
	print '';
      }
    }
  }
}


# my $exons = $gene_features->set(type => 'exons');
#
# $exons->cluster_and_create_genes;
#
# my $mRNAs->$gene_features->set(type => 'mRNA');
# $mRNAs->infer_features(infer_type => 'CDS');
#
# my $CDSs->$gene_features->set(type => 'CDS');
#
# my $cds_footprint = $CDSs->footprint;
#
# my $snp_features = GAL::Annotation->new(dsn  => 'dbi:mysql:NA19240_snps');
#
# $snp_features->load_file(file    => 'NA19240_snps.gff3',
#			      format  => 'solid',
#			     );
#
# my @genes = $gene_features->set(seqid  => 'chr1',
#				     type   => 'gene');
#
# for my $gene (@genes) {
#
#   for my $mRNA ($gene->children(type => 'mRNA')) {
#
#     my $CDSs = $mRNA->children->(type => 'CDS');
#     my $CDS  = $CDSs->longest;
#
#     my $snps = $snp_features->overlaps(feature => $CDS,
#					  type    => 'SNP');
#
#     while (my $snp = $snps->next) {
#
#       my $ref_allele = $snp->seq;
#
#       # Only dealing with one variant_allele;
#       my ($variant_allele) = $snp->attributes(variant_allele);
#       my $codons = $gene_features->set(type   => 'codon',
#					  parent => $CDS);
#
#       my $codon = $codons->overlaps(feature => $snp,
#				    parent  => $CDS,
#				    type    => 'codon');
#
#       my $codon_position  = $codon->my_coordinate($snp->start);
#       my $ref_codon_seq   = $codon->seq;
#       my $variant_codon_seq = $ref_codon_seq;
#       substr($variant_codon_seq, $codon_position - 1, $snp->length, $variant_allele);
#
#       $snp->variant_effect(feature => $CDS);
#     }
#   }
# }

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------
