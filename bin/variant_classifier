#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use GAL::Annotation;
use IO::Prompt;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

variant_classifier --fasta path/to/fasta --features feature.sqlite \
		   --variants variant.sqlite \

Description:

This script will take a genome annotation file, a variant file and classify
the functional effects of the variants against mRNA annotations.

Options:

  # Required
  fasta        A path to the fasta files associated with the give features.
  features     The database name for the features.
  variants     The database name for the variants.

  # Optional
  chr          Limit the analysis to a chromosome.
  parser       The format of the input file (a subclass of GAL::Parser) [gff3].
  driver       The type of storage to use MySQL or [SQLite]
  user         The database user.  Defaults first to \$ENV{\${driver}_user}
	       where \$driver is the driver parsed from the dsn. ['']
  password     The database password.   Defaults first to
	       \$ENV{\${driver}_password} where \$driver is the driver
	       parsed from the dsn.
  prompt       Prompt for the password on the command line.

";

my ($help, $driver, $fasta, $feature_db, $variant_db, $limit_chr,
    $user, $password, $prompt);

my $opt_success = GetOptions('help'          => \$help,
			     'driver=s'      => \$driver,
			     'fasta=s'       => \$fasta,
			     'features=s'    => \$feature_db,
			     'variants=s'    => \$variant_db,
			     'chr=s'         => \$limit_chr,
			     'user=s'        => \$user,
			     'password=s'    => \$password,
			     'prompt'        => sub {$password = prompt("Password: ", -tty,  -echo => '*')->{value}},
			      );

die $usage if $help || ! $opt_success;

die $usage unless ($feature_db && $variant_db);

$driver ||= 'SQLite';

# Making a hash of the arguments for the features and variants
my $feat_store_args = {class    => $driver,
		       database => $feature_db,
		       user     => $user,
		       password => $password,
		   };

my $var_store_args = {class    => $driver,
		      database => $variant_db,
		      user     => $user,
		      password => $password,
		     };

# Connect to the database for the features and variants
my $feat_store = GAL::Annotation->new(storage => $feat_store_args,
				      fasta   => $fasta,
				     );

my $var_store = GAL::Annotation->new(storage => $var_store_args,
				     fasta   => $fasta,
				    );
# Get a list of all the features and variants
my $features = $feat_store->schema->resultset('Feature');
my $variants = $var_store->schema->resultset('Feature');

# Set up the search
my %feature_where = (type => 'mRNA');
$feature_where{seqid} = $limit_chr if ($limit_chr);

# Get an interator for all matching features
my $mrnas = $features->search(\%feature_where);

# Iterate over the features
while (my $mrna = $mrnas->next) {
    # Get the feature ID
    my $mrna_id = $mrna->feature_id;
    # Get all the CDSs for this mRNA
    my $CDSs = $mrna->CDSs;
    # Iterate over each CDS
    while (my $CDS = $CDSs->next) {
        # Calculate which genomic bins this feature overlaps
	my $bins = $CDS->get_feature_bins;
        # Get my start and end
	my $cds_start = $CDS->start;
	my $cds_end   = $CDS->end;
	# Set up a new set of search criteria for overlapping variants
	# The addition of a bin column in the table makes range queries
	# much faster
	my %where = (bin   => {'-in' => $bins},
		     start => {'>='  => $cds_start},
		     end   => {'<='  => $cds_end},
		     );
	# Search for the overlapping variants
	my $these_variants = $variants->search(\%where);

	# Iterate over each variant
	while (my $variant = $these_variants->next) {
	    # Get data about the variant.
	    my $variant_id = $variant->feature_id;
	    my $seqid = $variant->seqid;
	    my $type  = $variant->type;
	    my $var_start = $variant->start;
	    my $reference_seq = $variant->reference_seq;
	    my @variant_seqs  = $variant->variant_seq_no_ref;

	    for my $variant_seq (@variant_seqs) {
		my $mrna_variant_seq = $variant_seq;
		# Some utility methods have to call the annotation object first.
		$mrna_variant_seq = $mrna->annotation->revcomp($variant_seq)
		    if $mrna->strand eq '-';
		# The various features have various useful methods according
		# to their type.
		my ($ref_codon, $offset) = $mrna->codon_at_location($var_start);
		unless ($ref_codon) {
		    warn "WARN : invalid_codon_lookup : $variant_id\n";
		    next;
		}
		# Another utility method that is supplied by the annotation object.
		my $ref_aa = $mrna->annotation->translate($ref_codon);
		my $var_codon = $ref_codon;
		substr($var_codon, $offset, 1, $mrna_variant_seq);
		my $var_aa = $mrna->annotation->translate($var_codon);
		my $effect;
		if ($ref_aa eq $var_aa) {
		    $effect = 'synonymous_codon';
		}
		elsif ($ref_aa eq '*') {
		    $effect = 'stop_lost';
		}
		elsif ($var_aa eq '*') {
		    $effect = 'stop_gained';
		}
		else {
		    $effect = 'non_synonymous_codon';
		}
		print join "\t", ($seqid,
				  $var_start,
				  $mrna_id,
				  $variant_id,
				  $reference_seq,
				  $variant_seq,
				  $ref_codon,
				  $var_codon,
				  $ref_aa,
				  $var_aa,
				  $effect,
				  );
		print "\n";
		print '';
	    }
	}
    }
}
