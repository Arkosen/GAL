#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Set::IntSpan::Fast;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

Synopsis:

snv_ontology_report --association gene_association.txt --diff \
                    --gff gene_annotations.gff                \
		    --ns_expect 0.77                          \
                    --list variant_file_list.txt              \
                    [file.gvf ...]

Description:

This script takes a variant annotation file (SNV only right now) in GVF or
c_snp_classifier format, and association file that links the IDs (probably
transcript IDs) in the variant annotation file to gene symbols and gene
symbols to ontology terms.  It will print a variety of reports (a la CSHL
PG 2009 Meeting) for the counts of variants within ontology term, gene
and transcript footprints as well as differences from expected (random 
distribution of all variants into total CDS footprint) values for each
of those counts.

Options:

  association    A mapping file that associates genes with ontology terms.  Currently
                 the expected format is tab separated values for transcript ID, gene ID,
                 and ontology term.  The transcript ID is the IDs used to annotate
                 variants in the GVF file.  The gene ID is a gene symbol that 
                 are associated with terms in the ontology.
  cols	         Comma separate values for columns (transcript_id, gene_id, term)
                 in the ontology association file [0,1,2]
  syn	         Include synonymous SNVs in analysis.  Default is to exclude
		 synonymous SNVs from analysis.
  diff	         Report percent differences from random distribution in terms/class.
  full           Print a full report of SNV counts for each transcript/gene in term/class.
  normal         Print a count of variants per megbase of CDS in term/class.
		 Default is to report raw SNV counts by ontology term.
  gff            A GFF file to calculating CDS and class footprints which are
		 used to calculate expected variant counts.
  ns_expect      A real number representing the fraction of changes that would
		 be expected to be non_synonymous based on the genetic code and
		 codon usage for a given proteome. If you pass a protein fasta file
		 for the genome the script will calculate the value for you. This last
                 function is not yet implimented.  The default value is 0.77 
                 calculated for the human proteome.  See Note below.
  list           A list file that determines the variant files to analyze with tab
                 seperated in the format values for file_name, format (gvf, c_snp),
                 sort_order, display_name.
  exclude        A list of classes to exclude from the mapping. [none]

Note: The default ns_expect was calculated as follows:

#/home/bmoore/Projects/10-02-12_Tim_Ley_AML_Genomes/analysis/bin/cgl_protein_codon_usage
perl -lane 'print \$F[-1]' /home/bmoore/Projects/10-02-12_Tim_Ley_AML_Genomes/data/WashU/10-03-01_data/c_snp_classifier/ucsc_kg_refseq/cgl_protein_codon_usage.out | statistics_descrpt
Stats-
mean0.77083062488389

";

my ($help, $ass_file, $cols_text, $syn, $diff, $full, $normal, $gff, $ns_expect,
    $list_file, $exclude);
my $opt_success = GetOptions('help'	     => \$help,
			     'association=s' => \$ass_file,
			     'cols=s'        => \$cols_text,
			     'syn'           => \$syn,
			     'diff'          => \$diff,
			     'full'          => \$full,
			     'normal'        => \$normal,
			     'gff=s'         => \$gff,
			     'ns_expect=s'   => \$ns_expect,
			     'list=s'        => \$list_file,
			     'exclude=s'     => \$exclude,
			     );

die $usage if $help || ! $opt_success;

die $usage unless -e $ass_file && (-e $list_file || ! grep {! -e} @ARGV);

$cols_text ||= '0,1,2';
my @cols = split /,/, $cols_text;

my $cmd_line_files = @ARGV;
my $files = parse_list_file($list_file, $cmd_line_files);

my ($trns_map, $gene_map, $term_map) = parse_association($ass_file, \@cols);
my $snv_counts = parse_variant_files($files);

my $term_footprints;
$term_footprints = calculate_footprints($gff, $trns_map);
$ns_expect ||= 0.77;
$ns_expect = calculate_ns_expect($ns_expect) if -e $ns_expect;

my %excludes = map {$_ => 1} split /\s+/, $exclude if $exclude;

my @subjects = map {$files->{$_}{subject}} sort {$files->{$a}{order} <=> $files->{$b}{order}} keys %{$files};

my @term_names = grep {! $excludes{$_}} keys %{$term_map};
my $mean_coding_snv;
map {$mean_coding_snv += scalar keys %{$snv_counts->{$_}{all}}} keys %{$snv_counts};
$mean_coding_snv /= scalar keys %{$snv_counts};

my $cds_footprint = $term_footprints->{ALL_CDS};
print "CDS footprint: $cds_footprint\n";

unless ($full) {
    print join "\t", ('', @subjects);
    print "\n";
}


for my $term (sort @term_names) {
    print "$term\n";
    for my $subject (@subjects) {
	my $snv_obsv = scalar keys %{$snv_counts->{$subject}{term}{$term}};
	$snv_obsv ||= 0;
	
	my $coding_snvs = scalar keys %{$snv_counts->{$subject}{all}};
	my $term_footprint = $term_footprints->{$term};
	my $snv_expect = ($coding_snvs * ($term_footprint / $cds_footprint));
	$snv_expect *= $ns_expect if ! $syn;
	my $pct_diff = $snv_obsv / $snv_expect * 100;
	$pct_diff = sprintf("%.0f", $pct_diff);
	
	if ($full) {
	    print "\t" . sprintf ("%10s", $subject);
	    for my $gene_id (keys %{$term_map->{$term}{gene}}) {
	    # for my $gene_id (keys %{$snv_counts->{$subject}{gene}}) {
		my $gene_count = ref $snv_counts->{$subject}{gene}{$gene_id} ? scalar keys %{$snv_counts->{$subject}{gene}{$gene_id}} : 0;
		printf("%-15s", "\t$gene_id: $gene_count");
		# for my $trns_id (keys %{$gene_map->{$gene_id}{trns}}) {
		#     my $trns_count = scalar keys %{$snv_counts->{$subject}{trns}{$trns_id}};
		#     print "\t$trns_id: $trns_count";
		# }
	    }
	    print "\n";
	}
	elsif ($diff) {
	    print "$pct_diff\t";
	}
	elsif ($normal) {
	    my $normal_count = int($snv_obsv / $term_footprint * 1000000); #  / $coding_snvs * $mean_coding_snv
	    print "$normal_count\t";
	}
	else {
	    print "$snv_obsv\t";
	}
    }
    print "\n";
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub parse_variant_files {
    my $files = shift;

    my %snv_counts;
    for my $file (keys %{$files}) {

	my $subject = $files->{$file}{subject};
	my $format  = $files->{$file}{format};
	
	open (my $IN, '<', $file) or die
	    "Can't open $file for reading\n$!\n";
	
	while (<$IN>) {
	    chomp;
	    last if /^\s*\#\#FASTA/;
	    next if /^\s*\#/;
	    next if /^\s*$/;
	    my @effects;
	    if ($format eq 'gvf') {
		my ($seqid, $source, $feat_type, $start, $end, $score, $strand,
		    $phase, $attribute_text) = split /\t/, $_;
		my %attributes;
		my @pairs = split /;/, $attribute_text;
		for my $pair (@pairs) {
		    my ($key, $value_text) = split /=/, $pair;
		    my @values = split /,/, $value_text;
		    $attributes{$key} = \@values;
		}
		# my $reference_seq = $attributes{Reference_seq}[0];
		my $index=0;
		my %variants; # = map {$index++ => {seq => $_} unless $_ eq $reference_seq} @{$attributes{Variant_seq}};
		for my $effect_text (@{$attributes{Variant_effect}}) {
		    # Variant_effect=non_synonymous_codon:mRNA:RefSeq:NM_001130045:.:0,amino_acid_substitution:polypeptide:RefSeq:NM_001130045:p.G25S:0;
		    my ($effect, $intersect_type, $db, $trns_id, $desc, $index) = split /:/, $effect_text;
		    next unless $intersect_type eq 'mRNA';
		    push @{$variants{$index}{$effect}}, $trns_id;
		}
		for my $index (keys %variants) {
		    my ($effect) =  (sort {scalar @{$variants{$index}{$a}} <=> 
					       scalar @{$variants{$index}{$b}}}
				     keys %{$variants{$index}});
		    my @trns_ids = @{$variants{$index}{$effect}};
		    my $location = join ':', ($seqid, $start, $end);
		    map {push @effects, [$location, $_, $effect]} @trns_ids;
		}
	    }
	    elsif ($format eq 'c_snp') {
		die "Fatal : need_to_validate_c_snp_classifier_parsing : $format\n";
		my ($subj_id, $contig_id, $gene_id, $trns_id, $ucsc_id, $snp_id,
		    $c_pos, $class, $allele, $wt_allele, $mut_allele, $wt_aa,
		    $mt_aa, $type, $mtx_score, $p_pos, $snp_strand, $trn_strand,
		    $multi) = split /\t/, $_;
		
		if ($type eq 'not_caught') {
		    warn "Warn : type_not_caught : $_\n";
		}
		else {
		    my $location = join ':', ($contig_id, $c_pos, $c_pos);
		    my $effect = $type;
		    push @effects, [$location, $trns_id, $effect];
		}
	    }
	    else {
		die "Fatal : unknown_format : $format\n";
	    }
	    
	    for my $effect_data (@effects) {
		my ($location, $trns_id, $effect) = @{$effect_data};
		
		$snv_counts{$subject}{all}{$location}++;

		next if $effect =~ /^synonymous/  && ! $syn;
		
		$trns_id = uc $trns_id;

		$snv_counts{$subject}{trns}{$trns_id}{$location}++;
		my @genes = ref $trns_map->{$trns_id}{gene} ? keys %{$trns_map->{$trns_id}{gene}} : ('Unknown');
		map {$snv_counts{$subject}{gene}{$_}{$location}++} @genes;
		my @terms = ref $trns_map->{$trns_id}{term} ? keys %{$trns_map->{$trns_id}{term}} : ('Unmapped');
		map {$snv_counts{$subject}{term}{$_}{$location}++} @terms;

	    }
	}
    }
    return \%snv_counts;
}

#-----------------------------------------------------------------------------

sub parse_association {

    my ($map_file, $cols) = @_;

    open (my $IN, '<', $map_file) or
	die "Can't open $map_file for reading\n$!\n";

    my (%trns_map, %gene_map, %term_map);
    while (<$IN>) {
	chomp;
	my ($trns_id, $gene_id, $term);
	my @fields = split /\t/, $_;
	($trns_id, $gene_id, $term) = @fields[@{$cols}];
	$gene_id = uc $gene_id;
	$trns_map{$trns_id}{gene}{$gene_id}++;
	$trns_map{$trns_id}{term}{$term}++;
	$gene_map{$gene_id}{trns}{$trns_id}++;
	$gene_map{$gene_id}{term}{$term}++;
	$term_map{$term}{trns}{$trns_id}++;
	$term_map{$term}{gene}{$gene_id}++;
    }
    return \%trns_map, \%gene_map, \%term_map;
}

#-----------------------------------------------------------------------------

sub parse_list_file {

    my $list_file = shift;

    open (my $IN, '<', $list_file) or
	die "Can't open $list_file for reading\n$!\n";

    my %files;
    while (<$IN>) {
	next if /^\#/;
	next if /^\s*$/;
	my ($file, $format, $order, $subject) = split /\s+/, $_;
	$files{$file} = {format  => $format,
			 order   => $order,
			 subject => $subject,
		     };
    }
    return \%files;
}

#-----------------------------------------------------------------------------

sub calculate_footprints {

    my ($gff, $trns_map) = @_;

    open (my $IN, '<', $gff) or die "Can't open $gff for reading\n";

    my %coordinates;
    while (my $line = <$IN>) {
	last if $line =~ /\#\#FASTA/;
	next if $line =~ /^\s*\#/;
	next if $line =~ /^\s*$/;
	my ($seqid, $source, $type, $start, $end, $score, $strand, $phase,
	    $attribute_text) = split /\t/, $line;
	next unless $type eq 'CDS';
	my ($parent) = $attribute_text =~ /Parent=(.*?);/;
	die "Fatal : CDS_has_no_parent : $line\n" unless $parent;

	######################
	######################
	# Temporary Hack !!! #
	$parent =~ s/:mRNA$//;
	######################
	######################

	my @terms = keys %{$trns_map->{$parent}{term}};
	push @terms, 'ALL_CDS';
	map {push @{$coordinates{$_}{$seqid}}, ($start, $end)} @terms;
    }

    my %term_footprints;
    for my $term (keys %coordinates) {
	for my $seqid (keys %{$coordinates{$term}}) {
	    my $set = Set::IntSpan::Fast->new();
	    my $these_coordinates = $coordinates{$term}{$seqid};
	    $set->add_range(@{$these_coordinates});
	    $term_footprints{$term} += scalar $set->as_array;
	}
    }
    return \%term_footprints;
}

#-----------------------------------------------------------------------------

sub calculate_ns_expect {



}

#-----------------------------------------------------------------------------
