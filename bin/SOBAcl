#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use GAL::Schema;
use DBI;
use Template;
use List::Util;
use List::MoreUtils;
use Statistics::Descriptive;
use Set::IntSpan::Fast;
use Text::Graph;
use Text::Graph::DataSet;
use Text::Table;
use Number::Format;
use SQL::Abstract;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

SOBAcl [options] db_name
SOBAcl [options] file.gff3

SOBAcl file.gff3 > soba_count.txt

SOBAcl --create_db file.gff3 db_name
SOBAcl db_name > soba_count.txt

See the Examples section below for more examples.

Description:

The Sequence Ontology Bioinformatics Analysis command line tool
(SOBAcl) will generate a variety of reports from the data in GFF3
files.  The data can optionally first be loaded into a database.  All
reports can be generated from a database, and some reports can only
be generated from a database, but many of the reports can also be
generated directly from a GFF3 file.

Options:

  --title      A title for the table, graph, or report.

  --columns    The columns parameter indicates how data will be grouped
  [--series]   into columns (or series for axis graphs and seperate
	       graphs for pie graphs).  For example, using seqid as
	       the value would create one column of data for each
	       seqid (chromosome).  For bar and line graphs there
	       would be a data series for each column.  For pie
	       graphs, a separate graph would be generated for each
	       column. (seqid, source, type, strand, phase, [file], stats).

  --rows       The rows parameter indicates data will be grouped into rows
  [--x_axis]   (x-axis labels for graphs with axes; wedges for pie
	       graphs).  For example, using type as the value would create one row
	       of data for each unique feature type in the GFF3 file.
	       For bar and line graphs there would be one x-axis label
	       for each type and for pie graphs there would be one pie
	       wedge for each type. (seqid, source, [type], strand, phase, file)

  --data       The data parameter indicates which data fields (columns or
  [--y_axis]   attributes in the GFF3 file) will be reported.  For
	       example using score for the data parameter will create
	       a report on the scores of features. (seqid, source,
	       type, start, end, [length], score, strand, phase)

  --data_type The data_type parameter indicates how the data described
	       in the data parameter should be summarized.  For
	       example if data is length and data_type is 'mean', then
	       the mean length would be reported for each grouping of
	       the data. (count, [mean], harmonic_mean,
	       geometric_mead, median, mode, sum, min, max, variance,
	       standard deviation, range, footprint)

  --layout The layout parameter describes how the data will be
	       presented.  ([table], lines, bars, hbars, points, linespoints, area, pie)

  --format The format parameter determines how the output will be
	       formatted.  For all text based outputs the options are
	       (text, [tab], html, html_page, pdf).  For all graphical
	       layouts the options are (jpeg, [png], gif).

  --collapse   Collapse series data onto one graph.

  --report     A report summarizes the data in more complex ways than
	       is possible with a table or a graph.  Available report types are:
	       gene, attribute, gff, gvf, ontology, invalid_term.

  --so_file    The path to a Sequence Ontology OBO file.

  --select A statement (in SQL or in perl hash or array reference
	       notation) that will constrain the features that are
	       used in the report.  For example \"seqid = 'chr1' AND
	       source = 'FlyBase'\" would only report on features from
	       chromosome 1 that had a source FlyBase.  This same
	       constraint could be in given as \"seqid => 'chr1',
	       source => 'FlyBase'\".  See SQL::Abstract documentation
	       for use of the hash/array reference notation for
	       constraints.

  --output For graphics the give value will be used as a filename.  If
	      multiple files are generated then this value will be
	      prepended to the row/series value to generate the final
	      filename.  In either case the format type will be added
	      as an extension, so don't add you own.

  --driver    The RDMS system used for the given database.  The default
	      is SQLite, but mysql is also an option;

  --user      Database user name.  Defaults to your system user name.

  --password  Database password.

  --template  The name of a Template Toolkit template to process the
	      data with.

  --create    Create a new database and load the given file.

  --append    Append data in the given file to an existing database.

  --custom    Print a help page with infomation relevant to writing
	      custom templates.



Graph Options:

All graphs:
title width height t_margin b_margin l_margin r_margin logo logo_resize
logo_position transparent interlaced

Colours:
bgclr fgclr boxclr accentclr shadowclr shadow_depth labelclr
axislabelclr legendclr valuesclr textclr dclrs borderclrs cycle_clrs
accent_treshold

Axes graphs:
title x_label y_label long_ticks tick_length x_ticks y_tick_number
y_number_format y1_number_format y2_number_format x_label_skip
y_label_skip x_tick_offset x_label_position use_axis zero_axis
zero_axis_only y_max_value y_min_value axis_space text_space cumulate
overwrite correct_width

Axes graphs - values:
show_values values_vertical values_space values_format

Axes graphs (numerical X):
x_tick_number x_min_value, x_max_value x_number_format x_label_skip

Bar graphs:
bar_width bar_spacing bargroup_spacing line_types line_type_scale
line_width skip_undef

Axes graphs (Points):
markers
marker_size

Mixed graphs:
types
default_type

Legend:
legend_placement
legend_spacing
legend_marker_width
legend_marker_height
lg_cols

Pie graphs:
3d
pie_height
start_angle
suppress_angle
label



Examples:

# Create a default report directly from a GFF3 file.
SOBAcl file.gff3 > soba_type_counts.txt
SOBAcl file1.gff3 file2.gff3 > soba_type_counts.txt

# Load some data into the database
SOBAcl --create file.gff3 db_name
SOBAcl --add file.gff3    db_name

# Create a default report of feature counts from a database
SOBAcl db_name > soba_count.txt

# Various ways to create feature type length reports in different formats
SOBAcl --columns seqid --rows type --data length --data_type min --layout table --format html > soba_min_length.html
SOBAcl --columns source --rows type --data length --data_type max --layout table --format tab > soba_max_length.txt
SOBAcl --columns file --rows type --data length --data_type footprint --layout table --format html_page > soba_footprint_length.html

# Variouis ways to create other reports
SOBAcl --report gene --html_page db_name > soba_gene_models.html
SOBAcl --report intron_density --format png --dir graphics/ db_name
SOBAcl --report ontology --dir graphics/ db_name

# Create a custom report by supplying a template
SOBAcl --report gene_models --limit '{seqid => \"chr1\", source => \"FlyBase\"}' \
       --template my_template.tt db_name > my_gene_models.txt

";


my ($help, $title, $columns, $rows, $data, $data_type, $select,
    $layout, $report, $format, $collapse, $template, $so_file,
    $output, $USER, $PASSWORD, $driver, %graph, %gv, %gv_node,
    %gv_edge);

my $opt_success = GetOptions('help'	    => \$help,
			     'title'        => \$title,
			     'columns=s'    => \$columns,
			     'rows=s'	    => \$rows,
			     'data=s'	    => \$data,
			     'data_type=s'  => \$data_type,
			     'select=s'	    => \$select,
			     'layout=s'	    => \$layout,
			     'report=s'     => \$report,
			     'format=s'	    => \$format,
			     'collapse'     => \$collapse,
			     'so_file=s'    => \$so_file,
			     'output=s'     => \$output,
			     'user=s'	    => \$USER,
			     'password=s'   => \$PASSWORD,
			     'driver=s'     => \$driver,
			     'template=s'   => \$template,
			     'graph=s'      => \%graph,
			     'gv=s'         => \%gv,
			     'gv_node=s'    => \%gv_node,
			     'gv_edge=s'    => \%gv_edge,
			    );

die $usage if ($help || ! $opt_success);
#die custom_help() if $custom;

if ($layout eq 'graphviz') {
  $data = 'type';
  $data_type = 'count';
}
$data_type = $data_type eq 'range' ? 'sample_range' : $data_type;


my $args = {'title'     => $title,
	    'columns'   => $columns,
	    'rows'	=> $rows,
	    'data'	=> $data,
	    'data_type' => $data_type,
	    'select'	=> $select,
	    'layout'	=> $layout,
	    'format'	=> $format,
	    'collapse'  => $collapse,
	    'so_file'   => $so_file,
	    'output'    => $output,
	    'user'	=> $USER,
	    'password'  => $PASSWORD,
	    'driver'    => $driver,
	    'template'  => $template,
	    'graph'     => \%graph,
	    'gv=s'      => \%gv,
	    'gv_node'   => \%gv_node,
	    'gv_edge'   => \%gv_edge,
	   };

my @db_names = @ARGV;
die $usage unless @db_names;

my $include_path = $0 . '../templates/soba';
$include_path =~ s/SOBAcl//;
my $TT_CONFIG = {INCLUDE_PATH => $include_path};

for my $db_name (@db_names) {
  if ($db_name =~ /\.gff3?(\.gz|\.bz|\.zip)?$/) {
    $db_name = ($db_name =~ /.gz$/  ? "gunzip $db_name |" :
		$db_name =~ /.bz$/  ? "bunzip $db_name |" :
		$db_name =~ /.zip$/ ? "unzip $db_name |"  :
		$db_name
	       );
  }
  else {
    $db_name = join ':', ('dbi', $driver, $db_name);
  }
}

$args->{db_names} = \@db_names;
if ($report) {
  if ($report eq 'gene') {
    make_gene_report($args);
  }
  elsif ($report eq 'attributes') {
    make_attribute_report($args);
  }
  elsif ($report eq 'gff') {
    make_gff_report($args);
  }
  elsif ($report eq 'gvf') {
    make_gvf_report($args);
  }
  elsif ($report eq 'ontology') {
    make_ontology_report($args);
  }
  elsif ($report eq 'invalid_term') {
    make_invalid_term_report($args);
  }
  elsif ($report eq 'intron_density') {
    make_intron_density_report($args);
  }
  else {
    die "FATAL : invalid_report : $report";
  }
  exit;
}

$args->{columns}   ||= 'file';
$args->{rows}      ||= 'type';
$args->{data}      ||= $args->{rows};
$args->{data_type} ||= 'count';
$args->{layout}    ||= 'table';
$args->{format}    ||= 'text';
$args->{output}    ||= 'SOBAcl_graphic';
$args->{USER}      ||= $ENV{LOGNAME};
$args->{PASSWORD}  ||= '';
$args->{driver}    ||= 'SQLite';
$args->{title}     ||= join ' ', ($args->{rows},  $args->{data}, '(' . $args->{data_type} . ')');

if ($layout eq 'table') {
  my $data_set = build_data($args);
  $args->{data_set} = $data_set;
  make_table($args);
}
elsif ($layout =~ /^(lines|bars|hbars|points|linespoints|area|pie)$/) {
  my $class = "GD::Graph::$layout";
  $args->{class} = $class;
  eval "require $class";
  die "FATAL : cant_load_module : $@" if $@;
  my $data_set = build_data($args);
  $args->{data_set} = $data_set;
  make_graph($args);
}
elsif ($layout eq 'graphviz') {
  my $data_set = build_data($args);
  $args->{data_set} = $data_set;
  make_graphviz($args);
}

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub build_data {

  my $args = shift;

  my ($db_names, $columns, $rows, $data, $data_type, $layout, $select) =
    @{$args}{qw(db_names columns rows data data_type layout select)};

  ($columns, $rows) = ($rows, $columns) unless $args->{layout} eq 'table';

  my %data_set;
  my %all_columns;

  my $att_data;
  if ($data =~ /^\+/) {
    $data =~ s/&^\+//;
    $att_data++;
  }
  for my $db_name (@{$db_names}) {
    my $feature_iterator = make_iterator($db_name, $select);

    while (my $f = &{$feature_iterator}) {
      my $row     = $rows    eq 'file' ? $db_name : @{$f}{$rows};
      my $column  = $columns eq 'file' ? $db_name : @{$f}{$columns};

      $row    = $row    eq '.' ? 'NULL' : $row;
      $column = $column eq '.' ? 'NULL' : $column;

      $all_columns{$column}++;

      my $datum;
      if ($data eq 'length') {
	my ($start, $end) = @{$f}{qw(start end)};
	$datum = $end - $start;
      }
      elsif ($data eq $rows || $data_type eq 'count') {
	if ($att_data) {
	  $datum = 1 if  && exists $f->{attributes}{$data};
	}
	else {
	  $datum = 1;
	}
      }
      else {
	if ($att_data) {
	  $datum = (! exists $f->{attributes}{$data} ? 0 : $f->{attributes}{$data});
	}
	else {
	  $datum = ($f->{$data} eq '.' ? 0 : $f->{$data});
	}
      }

      if ($data_type =~ /^(count|mean|sum|variance|min|max|range)$/) {
	$data_set{$row}{$column}{stats} ||= Statistics::Descriptive::Sparse->new();
	$data_set{$row}{$column}{stats}->add_data($datum);
      }
      elsif ($data_type eq 'footprint') {
	$data_set{$row}{$column}{set} ||= Set::IntSpan::Fast->new();
	my ($start, $end) = @{$f}{qw(start end)};
	$data_set{$row}{$column}{set}->add_range($start, $end);
      }
      else {
	$data_set{$row}{$column}{stats} ||= Statistics::Descriptive::Full->new();
	$data_set{$row}{$column}{stats}->add_data($datum);
      }
    }
  }

  if ($data_type eq 'footprint') {
    for my $row (keys %data_set) {
      for my $column (keys %all_columns) {
	my $datum;
	if (exists $data_set{$row}{$column}{set}) {
	  my $ranges = $data_set{$row}{$column}{set}->iterate_runs();
	  while (my ($start, $end) = $ranges->()) {
	    $datum += abs($end - $start + 1);
	  }
	}
	else {
	  $datum ||= 0;
	}
	$data_set{$row}{$column}{stats}{footprint} = $datum;
      }
    }
  }

  for my $row (keys %data_set) {
    for my $column (keys %all_columns) {
      $data_set{$row}{$column} ||= undef;
    }
  }

  return \%data_set;
}

#-----------------------------------------------------------------------------

sub make_table {
  my $args = shift;

  my %templates = (html      => 'soba_table_html.tt',
		   html_page => 'soba_table_html_page.tt',
		   text      => 'soba_table_text.tt',
		   tab       => 'soba_table_tab.tt',
		  );

  add_text_table($args) if $args->{format} eq 'text';

  $template ||= $templates{$args->{format}};

  my $tt = Template->new($TT_CONFIG);

  $tt->process($template, $args);
}

#-----------------------------------------------------------------------------

sub add_text_table {

  my $args = shift;
  my $data_set = $args->{data_set};
  my $data_type = $args->{data_type};

  my $nf = Number::Format->new;
  my ($row) = keys %{$data_set};
  my @table_data;
  for my $row (sort keys %{$data_set}) {
    my @row_data = ($row);
    for my $column (sort keys %{$data_set->{$row}}) {
      my $datum;
      if ($data_type eq 'footprint') {
	$datum = $data_set->{$row}{$column}{stats}{footprint};
      }
      else {
	$datum = (exists $data_set->{$row}{$column}{stats}      ?
		  $data_set->{$row}{$column}{stats}->$data_type :
		  0
		 );
      }
      $datum = $nf->round($datum, 2);
      push @row_data, $datum
    }
    push @table_data, \@row_data;
  }
  my @columns = sort keys %{$data_set->{$row}};
  unshift @columns, $rows;
  @columns = map {$_, \'|'} @columns;
  unshift @columns,  \'|';
  my $table = Text::Table->new(@columns);
  $table->load(@table_data);

  $args->{text_table} = $table;
}

#-----------------------------------------------------------------------------

sub make_graph {
  my $args = shift;

  # Graph Options:
  #
  # All graphs:
  # title width height t_margin b_margin l_margin r_margin logo logo_resize
  # logo_position transparent interlaced
  #
  # Colours:
  # bgclr fgclr boxclr accentclr shadowclr shadow_depth labelclr
  # axislabelclr legendclr valuesclr textclr dclrs borderclrs cycle_clrs
  # accent_treshold
  #
  # Axes graphs:
  # x_label y_label long_ticks tick_length x_ticks y_tick_number
  # y_number_format y1_number_format y2_number_format x_label_skip
  # y_label_skip x_tick_offset x_label_position y_label_position
  # x_labels_vertical x_plot_values box_axis no_axes two_axes
  # y_plot_values use_axis zero_axis zero_axis_only y_max_value
  # y_min_value axis_space text_space cumulate overwrite correct_width
  #
  # Axes graphs - values:
  # show_values values_vertical values_space values_format
  #
  # Axes graphs (numerical X):
  # x_tick_number x_min_value x_max_value x_number_format x_label_skip
  #
  # Bar graphs:
  # bar_width bar_spacing bargroup_spacing line_types line_type_scale
  # line_width skip_undef
  #
  # Axes graphs (Points):
  # markers marker_size
  #
  # Mixed graphs:
  # types default_type
  #
  # Legend:
  # legend_placement legend_spacing legend_marker_width
  # legend_marker_height lg_cols
  #
  # Pie graphs:
  # 3d pie_height start_angle suppress_angle label

  my %graph_args = %{$args->{graph}};
  my @new_args   = ($graph_args{width} || 400, $graph_args{height} || 300);
  delete @graph_args{qw(width height)};

  $graph_args{title}  ||= $args->{title} || $args->{db_name};
  $graph_args{x_label} ||= $args->{rows};
  $graph_args{y_label} ||= "$args->{data} ($args->{data_type})";
  $graph_args{x_label_position} ||= 0.5;

  if ($args->{layout} eq 'area') {
    delete @graph_args{qw(

			   bar_width bar_spacing bargroup_spacing
			   line_types line_type_scale line_width
			   skip_undef markers marker_size types
			   default_type 3d pie_height start_angle
			   suppress_angle label

			)};
  }
  elsif ($args->{layout} =~ /^h?bars$/) {
    delete @graph_args{qw(

			   x_tick_number x_min_value x_max_value
			   x_number_format x_label_skip markers
			   marker_size types default_type 3d
			   pie_height start_angle suppress_angle label

			)};
  }
  elsif ($args->{layout} eq 'lines') {
    delete @graph_args{qw(

			   bar_width bar_spacing bargroup_spacing
			   line_types line_type_scale line_width
			   skip_undef markers marker_size types
			   default_type 3d pie_height start_angle
			   suppress_angle label

			)};
  }
  elsif ($args->{layout} eq 'linespoints') {
    delete @graph_args{qw(

			   bar_width bar_spacing bargroup_spacing
			   types default_type 3d pie_height
			   start_angle suppress_angle label

			)};
  }
  elsif ($args->{layout} eq 'mixed') {
    delete @graph_args{qw(

			   3d pie_height start_angle suppress_angle
			   label

			)};
  }
  elsif ($args->{layout} eq 'pie') {
    delete @graph_args{qw(

			   x_label y_label long_ticks tick_length
			   x_ticks y_tick_number y_number_format
			   y1_number_format y2_number_format
			   x_label_skip y_label_skip x_tick_offset
			   x_label_position y_label_position
			   x_labels_vertical x_plot_values box_axis
			   no_axes two_axes y_plot_values use_axis
			   zero_axis zero_axis_only y_max_value
			   y_min_value axis_space text_space cumulate
			   overwrite correct_width show_values
			   values_vertical values_space values_format
			   x_tick_number x_min_value x_max_value
			   x_number_format x_label_skip bar_width
			   bar_spacing bargroup_spacing line_types
			   line_type_scale line_width skip_undef
			   markers marker_size types default_type
			   legend_placement legend_spacing
			   legend_marker_width legend_marker_height
			   lg_cols

			)};
    $args->{collapse} = undef;
    $graph_args{suppress_angle} ||= 10;
  }
  elsif ($args->{layout} eq 'points') {
    delete @graph_args{qw(

			   bar_width bar_spacing bargroup_spacing
			   line_types line_type_scale line_width
			   skip_undef types default_type 3d pie_height
			   start_angle suppress_angle label

			)};
  }

  my ($data_set, $class, $format, $data_type) =
    @{$args}{qw(data_set class format data_type)};

  my $y_max_value = $graph_args{y_max_value};

  my ($first_series) = keys %{$data_set};
  my @x_values = sort keys %{$data_set->{$first_series}};
  if ($args->{collapse}) {
    my @graph_data;
    push @graph_data, \@x_values;
    for my $series (sort keys %{$data_set}) {
      my @series_data;
      for my $x_value (sort keys %{$data_set->{$series}}) {
	my $datum = $data_set->{$series}{$x_value}{stats}->$data_type;
	if ($y_max_value) {
	  $datum = $datum > $y_max_value ? $y_max_value : $datum;
	}
	push @series_data, $datum;
      }
      push @graph_data, \@series_data;
    }
    my $graph = $class->new(@new_args);
    $graph->set(%graph_args, legend_placement => 'RL') or die $graph->error;
    my @legend_keys = sort keys %{$data_set};
    $graph->set_legend(@legend_keys) if scalar @legend_keys > 1;
    my $gd = $graph->plot(\@graph_data) or die $graph->error;

    my $file   = $args->{output};
    $file =~ s/_$//;
    $file .= ".$format";
    open (my $OUT, '>', $file) or die "FATAL : cant_open_file_for_writing : $file\n";
    binmode $OUT;
    if ($format eq 'gif') {
      print $OUT $gd->gif;
    }
    elsif ($format eq 'jpeg') {
      print $OUT $gd->jpeg;
    }
    elsif ($format eq 'png') {
      print $OUT $gd->png;
    }
    close $OUT;
  }
  else {
    for my $series (sort keys %{$data_set}) {
      my @graph_data;
      push @graph_data, \@x_values;
      my @series_data;
      for my $x_value (sort keys %{$data_set->{series}}) {
	my $datum = $data_set->{$series}{$x_value}{stats}->$data_type;
	if ($y_max_value) {
	  $datum = $datum > $y_max_value ? $y_max_value : $datum;
	}
	push @series_data, $datum;
      }
      push @graph_data, \@series_data;
      my $graph = $class->new(@new_args);
      $graph->set(%graph_args) or die $graph->error;
      my $gd = $graph->plot(\@graph_data) or die $graph->error;
      my $file   = $args->{output};
      $file .= $series;
      $file .= ".$format";
      open (my $OUT, '>', $file) or die "FATAL : cant_open_file_for_writing : $file\n";
      binmode $OUT;
      if ($format eq 'gif') {
	print $OUT $gd->gif;
      }
      elsif ($format eq 'jpeg') {
	print $OUT $gd->jpeg;
      }
      elsif ($format eq 'png') {
	print $OUT $gd->png;
      }
      close $OUT;
    }
  }
}

#-----------------------------------------------------------------------------

sub make_graphviz {
  my $args = shift;

  # TODO: Handle erros
  eval "require GO::Parser";
  eval "require GraphViz";

  my $parser = new GO::Parser({handler => 'obj'});
  $parser->parse($args->{so_file});
  my $so_graph = $parser->handler->graph;

  my $data_set = $args->{data_set};

  for my $series (keys %{$data_set}) {
    my @term_names = keys %{$data_set->{$series}};;
    my @file_terms;
    for my $name (@term_names) {
      my $term = $so_graph->get_term_by_name($name);
      push @file_terms, $term if $term;
    }

    my $subgraph = $so_graph->subgraph_by_terms(\@file_terms);
    my $terms = $subgraph->get_all_nodes;

    my $gv = GraphViz->new(layout   => 'dot',
			   directed => '1',
			   ratio    => 'auto',
			   overlap  => 'scalexy',
			   bgcolor  => 'white',
			   name     => 'large',
			  );

    for my $term (@{$terms}){
      my $name = $term->name;
      my $label = $args->{gv_value} ? "$name\n" . $data_set->{$series}{$name}{stats}->$data_type : $name;
      my $fillcolor = $data_set->{$series}{$name} ? 'red' : 'black';
      $gv->add_node($term->name,
		    fontsize  => 13,
		    shape     => 'box',
		    style     => 'filled',
		    fontcolor => 'white',
		    fillcolor => $fillcolor,
		    #URL       => $term_url . $term->acc,
		   );
    }

    my %seen;
    for my $term1(@{$terms}){
      my $acc1 = $term1->acc;
      for my $term2(@{$terms}){
	my $acc2 = $term2->acc;
	next if $acc1 eq $acc2;
	my $relations = $subgraph->get_relationships_between_terms($acc1, $acc2);
	for my $relation (@{$relations}) {
	  $gv->add_edge($term1->name => $term2->name,
			label       => ' ' . $relation ->type(),
			dir         => 'back',
			style       => 'solid'
		       );
	  $seen{$term1->acc}{$term2->acc}++;
	}
      }
    }
    my $file = $args->{output};
    my $format = $args->{format};
    $file .= $series if scalar keys %{$data_set} > 1;
    $file =~ s/_$//;
    $file .= ".$format";
    open (my $OUT, '>', $file) or die "FATAL : cant_open_file_for_writing : $file\n";
    binmode $OUT;
    if ($format eq 'gif') {
      print $OUT $gv->as_gif;
    }
    elsif ($format eq 'jpeg') {
      print $OUT $gv->as_jpeg;
    }
    elsif ($format eq 'png') {
      print $OUT $gv->as_png;
    }
    elsif ($format eq 'text') {
      print $OUT $gv->as_text;
    }
    close $OUT;
  }
}
#-----------------------------------------------------------------------------

sub make_attribute_report {
  my $args = shift;

  die "FATAL : report_not_implimented : attribute\n";

}

#-----------------------------------------------------------------------------

sub make_gff_report {
  my $args = shift;

  die "FATAL : report_not_implimented : gff\n";

}

#-----------------------------------------------------------------------------

sub make_gvf_report {
  my $args = shift;

  die "FATAL : report_not_implimented : gvf\n";

}

#-----------------------------------------------------------------------------

sub make_ontology_report {
  my $args = shift;

  die "FATAL : report_not_implimented : gvf\n";

}

#-----------------------------------------------------------------------------

sub make_invalid_term_report {
  my $args = shift;

  die "FATAL : report_not_implimented : invalid_term\n";

}

#-----------------------------------------------------------------------------

sub make_intron_density_report {
  my $args = shift;

  die "FATAL : report_not_implimented : intron_density\n";

}

#-----------------------------------------------------------------------------

sub make_iterator {

  my ($db_name, $select) = @_;

  my $feature_iterator;
  if ($db_name =~ /\.gff3?(\.gz|\.bz|\.zip)?(\s\|)?$/) {
    my %where;
    if ($select) {
      %where = eval $select;
    }
    open (my $IN, $db_name) or die "FATAL : cant_open_file_for_reading : $db_name\n";
    $feature_iterator =
      sub {
	my %f;
      LINE:
	while (my $line = <$IN>) {
	  next LINE if $line =~ /^(\s*|\s*\#.*)$/;
	  chomp $line;
	  @f{qw(seqid source type start end score strand phase attributes)} =
	    split /\t/, $line;
	  my @pairs = split /;/, $f{attributes};
	  $f{attributes} = undef;
	  for my $pair (@pairs) {
	    my ($key, $value_text) = split /=/, $pair;
	    my @values = split /,/, $value_text;
	    push @{$f{attributes}{$key}}, @values;
	  }
	  if ($select) {
	  CONSTRAINT:
	    for my $key (keys %where) {
	      my $values = $where{$key};
	      my @values = ref $values eq 'ARRAY' ? @{$values} : ($values);
	      my $op = ($values[0] =~ /^(==|eq|!=|ne|<|lt|<=|le|>|gt|>=|ge|=~|!~)$/) ? shift @values : 'eq';
	      for my $contraint (@values) {
		my $compare = "'$f{$key}' $op '$contraint'";
		$compare =~ s/'//g if $op !~ /[eanltg]/;
		unless (eval $compare) {
		  undef %f;
		  next LINE;
		}
	      }
	    }
	  }
	  last;
	}
	return %f ? \%f : undef;
      }
    }
  else {
    my $dbh = DBI->connect($db_name, $USER, $PASSWORD);
    my ($where_stmt, @bind);
    if ($select) {
      my %where = eval $select;
      my $sql = SQL::Abstract->new;
      ($where_stmt, @bind) = $sql->where(\%where);
    }
    my $stmt = 'SELECT * FROM feature ';
    $stmt .= $where_stmt if $where_stmt;
    my $f_sth = $dbh->prepare($stmt);
    my $a_sth = $dbh->prepare('SELECT * FROM attribute where feature_id = ?');
    my $rv = $f_sth->execute(@bind);
    $feature_iterator =
      sub {
	my @data = $f_sth->fetchrow_array;
	return undef unless scalar @data;
	my %f;
	@f{qw(subject_id feature_id seqid source type start end score strand phase bin)} = @data;
	if ($args->{attributes}) {
	  $a_sth->execute($f{feature_id});
	  my $as = $a_sth->fetchall_arrayref;
	  my %a =	map {$_->[3] => $_->[4]} @{$as};
	  $f{attributes} = \%a;
	}
	return \%f;
      }
    }
  return $feature_iterator;
}

#-----------------------------------------------------------------------------

__END__

#SOBAcl --columns seqid --rows type --data score  --data_type median --layout table --format text dmel-all-r5.30_0001000.gff
#
#sub counts {
#
#  my ($db_name, $group_by, $template) = @_;
#
#  my $feature_iterator = make_iterator($db_name);
#
#  my $data_group = make_data_group($group_by);
#
#  my %counts;
#  while (my $f = &{$feature_iterator}) {
#    # $counts{$f->{source}}{$f->{type}}++;
#
#  }
#
#  my $tt = Template->new($TT_CONFIG);
#  $template ||= 'soba_counts.tt';
#
#  $tt->process($template, {counts => \%counts})
#    || die $tt->error();
#}
#
##-----------------------------------------------------------------------------
#
#sub lengths {
#
#  my ($db_name, $template) = @_;
#
#  my $feature_iterator = make_iterator($db_name);
#
#  my %data;
#  while (my $feature = &$feature_iterator) {
#    my ($source, $type, $start, $end) = @{$feature}{qw(source type start end)};
#    push @{$data{$source}{$type}}, [$start, $end];
#  }      my $stat = Statistics::Descriptive::Full->new();
#
#  for my $source (keys %data) {
#    for my $type (keys %{$data{$source}}) {
#      my $stat = Statistics::Descriptive::Full->new();
#      my $set = Set::IntSpan::Fast->new();
#      for my $coordinates (@{$data{$source}{$type}}) {
#	my ($start, $end) = @{$coordinates};
#	my $length = $end - $start;
#	$stat->add_data($length);
#	$set->add_range($start, $end);
#      }
#      my $ranges = $set->iterate_runs();
#      my $footprint;
#      while (my ($start, $end) = $ranges->()) {
#	$footprint += abs($end - $start);
#      }
#      $data{$source}{$type} = undef;
#      $data{$source}{$type}{stats} = $stat;
#      $data{$source}{$type}{footprint} = $footprint;
#    }
#  }
#
#  my $tt = Template->new($TT_CONFIG);
#  $template ||= 'soba_lengths.tt';
#
#  $tt->process($template, {data => \%data})
#    || die $tt->error();
#}
#
##-----------------------------------------------------------------------------
#
#sub length_fd {
#
#  my ($db_name, $template) = @_;
#
#  my $feature_iterator = make_iterator($db_name);
#
#  my %data;
#  while (my $feature = &$feature_iterator) {
#    my ($source, $type, $start, $end) = @{$feature}{qw(source type start end)};
#    my $length = $end - $start;
#    push @{$data{$source}{$type}}, $length;
#  }
#  for my $source (keys %data) {
#    for my $type (keys %{$data{$source}}) {
#      my $stat = Statistics::Descriptive::Full->new();
#      my $set = Set::IntSpan::Fast->new();
#      map {$stat->add_data($_)} @{$data{$source}{$type}};
#      my $pctl_10 = $stat->percentile(10) || $stat->min;
#      my $pctl_90 = $stat->percentile(90) || $stat->max;
#      my $range = abs($pctl_90 - $pctl_10);
#      my $bin_size = int($range / 10) || 1;
#      my @bins;
#      for (my $bin = $pctl_10; $bin < $pctl_90; $bin += $bin_size) {
#	push @bins, $bin;
#      }
#      @bins = ($stat->min, $stat->max) unless scalar @bins >= 2;
#      my ($min_first, $max_last);
#      if (scalar @bins && $bins[0] > $stat->min) {
#	unshift @bins, $stat->min;
#	$min_first++;
#      }
#      if (scalar @bins && $bins[-1] < $stat->max) {
#	push    @bins, $stat->max;
#	$max_last++;
#      }
#      my $fd = $stat->frequency_distribution_ref(\@bins);
#      $fd = {$bins[0] => scalar $stat->count} unless $fd;
#      print "$source\t$type\n";
#      my $graph = Text::Graph->new('Bar',
#				   maxlen => 80,
#				  );
#
#      my @data_lines = $graph->make_lines($fd,
#					   sort => sub { sort { $a <=> $b } @_ },
#					  );
#
#      my $max_label_length = length($stat->max);
#      my $line_length  = $max_label_length + 84;
#      map {$_ .= ' ' x (81 - length($_))} @data_lines;
#      my @labels = map {$_ . (' ' x ($max_label_length - length($_) + 1)) . ': '} @bins;
#      my $first_line = (shift @labels) . (shift @data_lines) if $min_first;
#      my $last_line = (pop @labels) . (pop @data_lines) if $max_last;
#      map {$_ = (shift @labels) . $_} @data_lines;
#      my @graph_lines;
#      push @graph_lines, '-' x $line_length;
#      push @graph_lines, "|\n";
#      if ($min_first) {
#	push @graph_lines, "$first_line|\n";
#	push @graph_lines, ('.' x $line_length) . "|\n";
#      }
#      push @graph_lines, join "|\n", @data_lines;
#      push @graph_lines, "|\n";
#      if ($max_last) {
#	push @graph_lines, ('.' x $line_length) . "|\n";
#	push @graph_lines, "$last_line|\n";
#      }
#      push @graph_lines, '-' x $line_length;
#      push @graph_lines, "|\n";
#      my $graph_string = join '', @graph_lines;
#      $data{$source}{$type} = $graph_string;
#      print "$source\t$type\n";
#      print "$graph_string\n";
#      print '';
#    }
#  }
#
#  my $tt = Template->new($TT_CONFIG);
#  $template ||= 'soba_length_fd.tt';
#
#  $tt->process($template, {data => \%data})
#    || die $tt->error();
#}
#
#  my ($features, $tt) = @_;
#
#  my %data;
#  for my $source ($features->get_column('source')->func('DISTINCT')) {
#    for my $type ($features->search({source => $source})->get_column('type')->func('DISTINCT')) {
#      my $stat = Statistics::Descriptive::Full->new();
#      my $set = Set::IntSpan::Fast->new();
#
#      my %where = (source => $source,
#		   type   => $type
#		  );
#      my $these_features = $features->search(\%where);
#      # Don't build objects, we don't need them
#      $these_features->result_class('DBIx::Class::ResultClass::HashRefInflator');
#
#      for my $feature ($these_features->all) {
#	my $start = $feature->{start};
#	my $end   = $feature->{end};
#	my $length = abs($end - $start);
#	$stat->add_data($length);
#      }
#      my $pctl_10 = $stat->percentile(10) || $stat->min;
#      my $pctl_90 = $stat->percentile(90) || $stat->max;
#      my $range = abs($pctl_90 - $pctl_10);
#      my $bin_size = int($range / 10) || 1;
#      my @bins;
#      for (my $bin = $pctl_10; $bin < $pctl_90; $bin += $bin_size) {
#	push @bins, $bin;
#      }
#      @bins = ($stat->min, $stat->max) unless scalar @bins >= 2;
#      my ($min_first, $max_last);
#      if (scalar @bins && $bins[0] > $stat->min) {
#	unshift @bins, $stat->min;
#	$min_first++;
#      }
#      if (scalar @bins && $bins[-1] < $stat->max) {
#	push    @bins, $stat->max;
#	$max_last++;
#      }
#      my $fd = $stat->frequency_distribution_ref(\@bins);
#      $fd = {$bins[0] => scalar $stat->count} unless $fd;
#      print "$source\t$type\n";
#      my $graph = Text::Graph->new('Bar',
#				   maxlen => 80,
#				  );
#
#      my @data_lines = $graph->make_lines($fd,
#					   sort => sub { sort { $a <=> $b } @_ },
#					  );
#
#      my $max_label_length = length($stat->max);
#      my $line_length  = $max_label_length + 84;
#      map {$_ .= ' ' x (81 - length($_))} @data_lines;
#      my @labels = map {$_ . (' ' x ($max_label_length - length($_) + 1)) . ': '} @bins;
#      my $first_line = (shift @labels) . (shift @data_lines) if $min_first;
#      my $last_line = (pop @labels) . (pop @data_lines) if $max_last;
#      map {$_ = (shift @labels) . $_} @data_lines;
#      my @graph_lines;
#      push @graph_lines, '-' x $line_length;
#      push @graph_lines, "|\n";
#      if ($min_first) {
#	push @graph_lines, "$first_line|\n";
#	push @graph_lines, ('.' x $line_length) . "|\n";
#      }
#      push @graph_lines, join "|\n", @data_lines;
#      push @graph_lines, "|\n";
#      if ($max_last) {
#	push @graph_lines, ('.' x $line_length) . "|\n";
#	push @graph_lines, "$last_line|\n";
#      }
#      push @graph_lines, '-' x $line_length;
#      push @graph_lines, "|\n";
#      my $graph_string = join '', @graph_lines;
#      $data{$source}{$type} = $graph_string;
#    }
#  }
#  $tt->process($template, {data => \%data})
#    || die $tt->error();
#}
#
##-----------------------------------------------------------------------------
#
#sub template {
#
#  my ($features, $template, $tt);
#
#  $tt->process($template, {features => $features})
#    || die $tt->error();
#}
#
##-----------------------------------------------------------------------------
